<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Shakespeare Digital Variorum</title>
    <link rel="stylesheet" href="styles/tokens.css?v=1.1">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            letter-spacing: 0.005em;
            transition: background-color .18s ease, color .18s ease, border-color .18s ease, box-shadow .18s ease;
        }

        ::selection {
            background: var(--hl);
        }

        html, body {
            background: var(--bg);
            color: var(--ink-1);
            font-family: var(--ui);
            line-height: 1.6;
            min-height: 100vh;
            scroll-behavior: smooth;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }

        body, button, input, select {
            font-family: "Inter", "SF Pro Text", system-ui, sans-serif;
            letter-spacing: .005em;
        }

        ::selection {
            background: var(--hl);
        }

        .container {
            max-width: 1320px;
            margin: 0 auto;
            padding: 0 var(--s-4);
        }

        .panel {
            background: var(--surface);
            border: 1px solid var(--line);
            border-radius: var(--r-sm);
            box-shadow: var(--shadow);
        }

        hr {
            border: 0;
            height: 1px;
            background: var(--line);
            margin: var(--s-4) 0;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 20;
            backdrop-filter: saturate(180%) blur(10px);
            background: rgba(247,247,248,.85);
            border-bottom: 1px solid var(--line);
            padding: var(--s-3) var(--s-4);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header .brand {
            font-weight: 700;
            letter-spacing: .01em;
        }



        .header h1 {
            font-size: 1.8em;
            color: var(--ink-1);
            font-weight: 600;
            font-family: var(--ui);
        }

        .header-nav {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .nav-btn {
            background: none;
            border: none;
            color: var(--ink-2);
            cursor: pointer;
            padding: 10px 16px;
            border-radius: var(--r-sm);
            font-size: 15px;
            font-weight: 500;
            font-family: var(--ui);
        }

        .nav-btn:hover {
            background: var(--panel);
            color: var(--ink-1);
        }

        .btn {
            border-radius: 12px;
            font-weight: 600;
            transition: filter .15s, transform .08s;
            cursor: pointer;
        }

        .btn-primary {
            border: 1px solid rgba(0,0,0,.06);
            background: #000000;
            color: #fff;
            padding: 10px 14px;
        }

        .btn-primary:hover {
            background: #333333;
        }

        .btn-primary:active {
            transform: translateY(1px);
            background: #1a1a1a;
        }

        .btn-ghost {
            background: var(--surface);
            color: var(--ink-2);
            border: 1px solid var(--line);
            padding: 8px 12px;
        }

        .btn-ghost:hover {
            background: #F2F4F7;
            color: var(--ink-1);
        }

        .explain-btn:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }



        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background: var(--surface);
            border: 1px solid var(--line);
            border-radius: var(--r-lg);
            box-shadow: var(--shadow);
            padding: var(--s-5);
            max-width: 820px;
            margin: 0 auto;
            position: relative;
            top: 50%;
            transform: translateY(-50%);
            max-height: 90vh;
            overflow: hidden;
            animation: modalIn .18s ease-out;
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--s-4);
        }

        .modal-title {
            font: 700 20px/1.2 Inter, system-ui;
            letter-spacing: -.01em;
            color: var(--ink-1);
        }

        .modal-close {
            background: transparent;
            border: 0;
            color: var(--ink-3);
            font-size: 20px;
            border-radius: 10px;
            padding: 6px;
            cursor: pointer;
        }

        .modal-close:hover {
            background: rgba(0,0,0,.05);
        }

        .modal-body {
            max-height: calc(90vh - 140px);
            overflow: auto;
            padding-right: var(--s-2);
        }

        .modal-footer {
            display: flex;
            justify-content: center;
            gap: var(--s-2);
            margin-top: var(--s-4);
            padding-top: var(--s-4);
            border-top: 1px solid var(--line);
        }

        .close-settings-btn {
            background: #000000;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            font-family: Inter, system-ui, sans-serif;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .close-settings-btn:hover {
            background: #333333;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        /* Focus ring & entry motion */
        .modal :focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
            border-radius: 6px;
        }

        @keyframes modalIn {
            from {
                transform: translateY(6px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* About content rhythm */
        .about h2 {
            font: 600 16px Inter, system-ui;
            color: var(--ink-1);
            margin: var(--s-4) 0 var(--s-2);
        }

        .about p {
            color: var(--ink-2);
            font-size: 16px;
            line-height: 1.6;
            margin: 0 0 var(--s-3);
        }

        .about .meta {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--s-3);
            margin: var(--s-4) 0;
        }

        .about .badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border: 1px solid var(--line);
            border-radius: 12px;
            background: var(--surface);
        }

        .about .callout {
            background: #F2F4F7;
            border: 1px solid var(--line);
            border-radius: 12px;
            padding: var(--s-3);
            color: var(--ink-2);
        }

        .about ul {
            margin: 0 0 var(--s-3) 1.1rem;
            color: var(--ink-2);
        }

        .about a {
            color: var(--accent);
            text-decoration: none;
        }

        .about a:hover {
            text-decoration: underline;
        }

        /* Settings layout + controls */
        .settings {
            display: grid;
            grid-template-columns: 220px 1fr;
            gap: var(--s-4);
        }

        .settings-nav {
            background: var(--panel);
            border: 1px solid var(--line);
            border-radius: var(--r-lg);
            padding: var(--s-3);
        }

        .settings-nav .item {
            padding: 10px 12px;
            border-radius: 12px;
            color: var(--ink-2);
            cursor: pointer;
        }

        .settings-nav .item:hover {
            background: #ECEFF3;
        }

        .settings-nav .item.active {
            background: var(--surface);
            border: 1px solid var(--line);
            box-shadow: var(--shadow);
            color: var(--ink-1);
        }

        .settings-pane {
            background: var(--surface);
            border: 1px solid var(--line);
            border-radius: var(--r-lg);
            box-shadow: var(--shadow);
            padding: var(--s-5);
        }

        .settings-pane h3 {
            font: 600 16px Inter;
            margin: 0 0 var(--s-2);
            color: var(--ink-1);
        }

        .settings-pane .sub {
            color: var(--ink-3);
            margin: 0 0 var(--s-3);
        }

        .settings-pane .row {
            display: grid;
            grid-template-columns: 220px 1fr;
            gap: var(--s-3);
            align-items: center;
            padding: 12px 0;
        }

        .settings-pane .row + .row {
            border-top: 1px solid var(--line);
        }

        /* Controls (inputs, selects, toggles, file) */
        .input, .select, .textarea {
            width: 100%;
            background: var(--surface);
            color: var(--ink-1);
            border: 1px solid var(--line);
            border-radius: 12px;
            padding: 10px 12px;
            transition: border-color .15s, box-shadow .15s;
        }

        .input:focus, .select:focus, .textarea:focus {
            border-color: #C7D7FE;
            box-shadow: 0 0 0 3px rgba(59,130,246,.15);
        }

        .toggle {
            position: relative;
            width: 44px;
            height: 26px;
            background: #E6E8EE;
            border-radius: 999px;
            transition: background .15s;
        }

        .toggle:after {
            content: "";
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #fff;
            box-shadow: var(--shadow);
            transition: left .15s;
        }

        .toggle[aria-checked="true"] {
            background: #C7D7FE;
        }

        .toggle[aria-checked="true"]::after {
            left: 21px;
        }

        .dropzone {
            border: 1px dashed var(--line);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            color: var(--ink-3);
        }

        .dropzone:hover {
            background: #F6F7FA;
        }

        .settings-actions {
            display: flex;
            justify-content: flex-end;
            gap: var(--s-2);
            margin-top: var(--s-4);
        }

        .danger {
            border: 1px solid #F2C6C6;
            background: #FFF6F6;
            color: #8C2F2F;
            border-radius: 12px;
            padding: var(--s-3);
        }

        .upload-section, .library-section {
            margin-bottom: 25px;
        }

        .upload-section h3, .library-section h3 {
            margin-bottom: 15px;
            color: var(--ink-1);
            font-size: 1.3em;
            font-weight: 600;
            font-family: var(--ui);
        }

        .upload-section h4 {
            margin: 20px 0 10px 0;
            color: var(--ink-1);
            font-size: 1.1em;
            font-weight: 600;
            font-family: var(--ui);
        }

        .single-upload, .bulk-upload {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .play-name-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e9ecef;
        }

        .play-name-section label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--ink-1);
            font-family: var(--ui);
        }

        .name-instructions {
            font-size: 12px;
            color: var(--ink-3);
            margin-top: 8px;
            font-style: italic;
            font-family: var(--ui);
        }

        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .play-input {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid var(--line);
            border-radius: 4px;
            font-family: var(--ui);
            font-size: 14px;
        }

        .add-btn, .update-btn {
            background: #000000;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }

        .add-btn:hover, .update-btn:hover {
            background: #333333;
        }

        .file-upload {
            border: 2px dashed #e2e8f0;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            transition: all 0.3s ease;
        }

        .file-upload:hover {
            border-color: #000000;
            background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%);
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        }

        .file-upload input[type="file"] {
            display: none;
        }

        .file-upload label {
            cursor: pointer;
            color: #000000;
            font-weight: 600;
            font-size: 1.1em;
            display: block;
            margin-bottom: 10px;
        }

        .file-upload label:hover {
            text-decoration: underline;
        }

        .upload-instructions {
            margin-top: 10px;
            font-size: 14px;
            color: var(--ink-3);
            font-family: var(--ui);
        }

        .uploaded-plays, .library-plays {
            margin-top: 20px;
        }

        .play-item, .library-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
            margin-bottom: 8px;
            border: 1px solid #e9ecef;
        }

        .play-name, .library-name {
            font-weight: 500;
            color: var(--ink-1);
            font-family: var(--ui);
        }

        .play-info {
            font-size: 12px;
            color: var(--ink-3);
            margin-top: 4px;
            font-family: var(--ui);
        }

        .remove-play, .delete-play {
            background: #dc3545;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
        }

        .remove-play:hover, .delete-play:hover {
            background: #c82333;
        }

        .library-item {
            background: white;
            border: 1px solid #dee2e6;
        }

        .library-item:hover {
            background: #f8f9fa;
        }

        .upload-success {
            background: #ffffff;
            color: #000000;
            padding: 10px 15px;
            border-radius: 4px;
            margin-top: 15px;
            border: 1px solid #000000;
            display: none;
        }

        .upload-error {
            background: #f8d7da;
            color: #721c24;
            padding: 10px 15px;
            border-radius: 4px;
            margin-top: 15px;
            border: 1px solid #f5c6cb;
            display: none;
        }
        
        /* Cache Management Styles */
        .cache-section {
            margin-top: 25px;
            padding-top: 25px;
            border-top: 1px solid #e9ecef;
        }
        
        .cache-section h3 {
            margin-bottom: 15px;
            color: var(--ink-1);
            font-size: 1.3em;
            font-weight: 600;
            font-family: var(--ui);
        }
        
        .cache-info p {
            color: var(--ink-2);
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 15px;
            font-family: var(--ui);
        }
        
        .cache-stats {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .cache-stat {
            margin-bottom: 8px;
            font-size: 14px;
            color: var(--ink-2);
            font-family: var(--ui);
        }
        
        .cache-stat:last-child {
            margin-bottom: 0;
        }
        
        .cache-actions {
            display: flex;
            gap: 10px;
        }
        
        .cache-actions .btn {
            flex: 1;
        }

        .about-content {
            line-height: 1.8;
            color: #2d3748;
            font-size: 1.05em;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        .about-content p {
            margin-bottom: 25px;
            text-align: justify;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        .about-footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #e9ecef;
            text-align: center;
        }

        .about-footer p {
            margin-bottom: 0;
            color: #6c757d;
        }

        /* Footer About Section */
        .footer-about {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--panel);
            border-top: 1px solid var(--line);
            padding: var(--s-4) var(--s-5);
            font-size: 14px;
            line-height: 1.5;
            color: var(--ink-3);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            gap: var(--s-2);
            box-shadow: 0 -1px 2px rgba(0, 0, 0, 0.03);
            z-index: 15;
            width: 100%;
        }

        .footer-about h3 {
            font-family: Inter, system-ui, sans-serif;
            font-weight: 600;
            letter-spacing: 0.01em;
            color: var(--ink-2);
            margin-bottom: var(--s-2);
        }

        .footer-title {
            font-family: Inter, system-ui, sans-serif;
            font-weight: 600;
            letter-spacing: 0.01em;
            color: var(--ink-2);
            margin-bottom: var(--s-2);
        }

        .footer-about p {
            max-width: 800px;
            margin: 0 auto 15px auto;
            color: var(--ink-3);
            line-height: 1.6;
            text-align: left;
        }

        .footer-about a {
            color: #000000;
            text-decoration: none;
            font-weight: 500;
        }

        .footer-about a:hover {
            text-decoration: underline;
        }

        .footer-attribution {
            font-size: 0.9em;
            color: var(--ink-3);
            margin-top: 20px;
            text-align: center;
        }

        .footer-attribution a {
            color: var(--accent);
            text-decoration: none;
            font-weight: 500;
        }

        .footer-attribution a:hover {
            text-decoration: underline;
        }



        /* Rights Modal */
        .rights-content {
            line-height: 1.7;
            color: #495057;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        .rights-content h4 {
            color: #2d3748;
            margin: 30px 0 15px 0;
            font-size: 1.2em;
            font-weight: 600;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        .rights-content h4:first-child {
            margin-top: 0;
        }

        .rights-content p {
            margin-bottom: 20px;
            font-size: 15px;
        }

        .rights-footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #e9ecef;
            text-align: center;
        }

        .rights-footer h4 {
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .rights-footer p {
            margin-bottom: 5px;
            color: #6c757d;
        }

        .rights-footer a {
            color: #007bff;
            text-decoration: none;
        }

        .rights-footer a:hover {
            text-decoration: underline;
        }

        .close-rights-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 25px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 20px;
        }

        .close-rights-btn:hover {
            background: #0056b3;
        }

        .modal-close-btn {
            background: #000000;
            color: white;
            border: none;
            padding: 10px 25px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 20px;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .modal-close-btn:hover {
            background: #333333;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        /* Main Layout */
        .layout {
            display: grid;
            grid-template-columns: 1.5fr minmax(600px, 45%);
            gap: var(--s-4);
            height: calc(100vh - 70px);
            background: var(--bg);
            position: relative;
            overflow: hidden;
            margin-top: 70px;
            margin-left: 280px;
        }

        @media (min-width: 1600px) {
            .layout {
                grid-template-columns: 2fr minmax(700px, 40%);
            }
        }

        @media (max-width: 1200px) {
            .layout {
                grid-template-columns: 1.25fr minmax(550px, 45%);
            }
        }

        @media (max-width: 900px) {
            .layout {
                grid-template-columns: 1fr minmax(500px, 50%);
            }
            .sidebar {
                width: 250px;
                left: var(--s-2);
            }
            .layout {
                margin-left: 250px;
            }
        }

        /* Sidebar */
        .sidebar {
            background: var(--panel);
            border: 1px solid var(--line);
            border-radius: var(--r-lg);
            padding: var(--s-3) var(--s-2);
            position: fixed;
            top: 70px;
            left: var(--s-4);
            width: 280px;
            height: calc(100vh - 70px - 150px - var(--s-4) * 2);
            overflow-y: auto;
            box-shadow: var(--shadow);
            z-index: 10;
        }

        /* top/bottom scroll cues like Apple */
        .sidebar::before,
        .sidebar::after {
            content: "";
            position: sticky;
            left: 0;
            right: 0;
            height: 12px;
            pointer-events: none;
            z-index: 1;
        }

        .sidebar::before {
            top: 0;
            box-shadow: inset 0 8px 8px -8px rgba(0,0,0,.08);
        }

        .sidebar::after {
            bottom: 0;
            box-shadow: inset 0 -8px 8px -8px rgba(0,0,0,.08);
        }

        /* === Sidebar Navigation Styling (Notion × Apple aesthetic) === */

        /* Reset link colors so visited links don't go purple */
        .sidebar a,
        .sidebar a:visited {
            color: var(--ink-2);
            text-decoration: none;
            display: block;
        }

        /* Hover and active styles */
        .sidebar a:hover {
            background: #ECEFF3;
            color: var(--ink-1);
        }

        .sidebar .active,
        .sidebar .active:visited {
            background: transparent;
            border: none;
            box-shadow: none;
            color: var(--ink-1);
            font-weight: 700;
        }

        /* ACT headings (keep, replace "Navigation") */
        .nav-section-title {
            font: 600 12px/1 Inter, system-ui, sans-serif;
            letter-spacing: .06em;
            text-transform: uppercase;
            color: var(--ink-3);
            margin: var(--s-3) 0 var(--s-2);
            padding: 0 var(--s-2);
        }

        /* Scene links (no purple, no white-out; clear active) */
        /* unify colors; kill :visited purple */
        .sidebar a, .sidebar a:visited {
            color: var(--ink-2);
            text-decoration: none;
            display: block;
        }

        /* base item */
        .nav-item {
            padding: 8px 12px;
            margin: 2px 0;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 500;
            transition: background-color .15s ease, color .15s ease, box-shadow .15s ease, border-color .15s ease;
        }

        /* hover */
        .nav-item:hover {
            background: #ECEFF3;
            color: var(--ink-1);
        }

        /* active scene = bold text instead of white box */
        .nav-item.active,
        .nav-item[aria-current="page"] {
            background: transparent;
            color: var(--ink-1);
            border: none;
            box-shadow: none;
            font-weight: 700;
        }

        /* selected ACT in the list can be slightly bolder */
        .nav-item.act {
            font-weight: 600;
        }

        /* Focus & a11y */
        .nav-item:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }

        /* Optional: tighter vertical rhythm */
        .nav-group {
            padding: 0 var(--s-2);
            margin-bottom: var(--s-3);
        }

        .play-selector-container {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .play-selector {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-family: inherit;
            font-size: 14px;
            min-width: 0; /* Allow flex item to shrink */
        }
        
        .play-selector option {
            word-wrap: break-word;
            white-space: normal;
            max-width: 200px;
        }
        
        .go-btn {
            padding: 8px 16px;
            background: #000000;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .go-btn:hover {
            background: #333333;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .cancel-btn {
            padding: 8px 16px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            margin-left: 8px;
        }
        
        .cancel-btn:hover {
            background-color: #545b62;
        }
        
        .bulk-rename-section {
            margin-top: 15px;
        }
        
        .bulk-rename-list {
            margin: 15px 0;
        }
        
        .bulk-rename-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        
        .bulk-rename-item label {
            min-width: 80px;
            font-weight: 500;
        }
        
        .bulk-name-input {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .original-filename {
            color: #6c757d;
            font-size: 12px;
            font-style: italic;
        }

        .navigation-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .navigation-list li {
            margin-bottom: 2px;
        }

        .navigation-list .sub-item {
            margin-left: 15px;
            font-size: 12px;
        }

        .navigation-list .sub-item a {
            padding: 4px 8px;
        }

        /* Reading Pane */
        .reader {
            background: var(--surface);
            padding: var(--s-5);
            overflow-y: auto;
            overflow-x: hidden;
            border: 1px solid var(--line);
            border-radius: var(--r-md);
            box-shadow: var(--shadow);
            width: 100%;
            min-width: 0;
            word-wrap: break-word;
            height: calc(100vh - 70px - 150px - var(--s-4) * 2);
        }

        .scene-title {
            font-size: 1.4em;
            font-weight: 600;
            margin-bottom: 24px;
            color: #2d3748;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 14px;
        }

        .scene-separator {
            border-top: 1px solid rgba(0,0,0,0.08);
            margin: 24px 0;
        }

        .stage-direction {
            font-style: italic;
            color: #6b7280;
            margin: 12px 0;
            padding: 4px 0;
            font-family: 'Charter', 'Georgia', 'Times New Roman', serif;
            font-size: 14px;
            line-height: 1.6;
        }

        .dialogue {
            margin: 16px 0;
            padding: 8px 0;
        }

        .character-name {
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 16px;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 8px;
        }

        .play {
            font-family: var(--ui);
            font-size: 16px;
            line-height: 1.6;
            width: 100%;
            margin: 0;
            word-wrap: normal;
            overflow-wrap: normal;
            hyphens: none;
        }

        .dialogue-text {
            font-size: 15px;
            line-height: 1.6;
            color: #374151;
            margin-bottom: 8px;
        }

        .play .scene-title {
            font-family: Inter;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: .06em;
            font-size: 13px;
            color: var(--ink-3);
            margin-bottom: var(--s-2);
        }

        .play .stage {
            font-style: italic;
            color: var(--ink-3);
        }

        .play .speaker {
            font-variant-caps: small-caps;
            letter-spacing: .04em;
        }

        /* Verse line styling - preserve Shakespearean line structure */
        .play .line {
            display: block;
            white-space: normal;
            word-break: normal;
            overflow-wrap: normal;
            max-width: 100%;
            overflow: visible;
        }

        /* Stage directions and prose can still wrap nicely */
        .play .stage {
            font-style: italic;
            color: var(--ink-3);
            white-space: normal;
        }

        .play .prose {
            white-space: normal;
            max-width: 100%;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        /* Ensure text uses full available width */
        .reader * {
            box-sizing: border-box;
        }

        .play * {
            word-wrap: normal;
            overflow-wrap: normal;
            white-space: normal !important;
        }
        
        /* Force proper text display for play content */
        .play .line,
        .play .stage,
        .play .prose,
        .play .dialogue {
            white-space: normal !important;
            word-break: normal !important;
            overflow-wrap: normal !important;
            word-wrap: normal !important;
        }

        /* Responsive text sizing for different screen sizes */
        @media (max-width: 1200px) {
            .play {
                font-size: 15px;
            }
        }

        @media (max-width: 900px) {
            .play {
                font-size: 14px;
            }
        }

        @media (max-width: 600px) {
            .play {
                font-size: 13px;
            }
        }



        /* Graceful degradation on narrow screens */
        @media (max-width: 1200px) {
            .play, .play .line {
                white-space: normal;
            }
        }

        .dialogue-text {
            line-height: 1.58;
            white-space: pre-line;
            font-family: var(--ui);
            font-size: 18px;
            max-width: 72ch;
            color: var(--ink-1);
            word-wrap: normal;
            overflow-wrap: normal;
            word-break: normal;
            margin: 8px 0;
        }
        
        .play-line {
            font-family: var(--ui);
            font-size: 16px;
            line-height: 1.6;
            color: var(--ink-1);
            margin: 0;
            white-space: pre;
            font-family: monospace;
        }

        .highlight {
            background: #e5e7eb;
            border-radius: 4px;
            transition: background .18s;
            /* Preserve original text formatting */
            font-family: inherit;
            font-size: inherit;
            font-weight: inherit;
            font-style: inherit;
            line-height: inherit;
            white-space: inherit;
            word-wrap: inherit;
            overflow-wrap: inherit;
            word-break: inherit;
        }

        /* Analysis Mode Selector */
        .analysis-mode-selector {
            background: white;
            padding: 20px;
            border-radius: 6px 6px 0 0;
            border-bottom: 1px solid rgba(0,0,0,0.08);
            margin-bottom: 0;
        }

        .segment {
            display: inline-flex;
            background: var(--panel);
            border: 1px solid var(--line);
            border-radius: 999px;
            padding: 4px;
            gap: 4px;
        }

        .segment button {
            background: transparent;
            border: 0;
            padding: 8px 14px;
            border-radius: 999px;
            color: var(--ink-2);
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.15s ease, color 0.15s ease;
        }

        .segment button[aria-pressed="true"] {
            background: #000000;
            box-shadow: var(--shadow);
            color: #ffffff;
        }

        /* ====== Analysis Container: All Levels ====== */
        .analysis {
            background: var(--surface);
            border: 1px solid var(--line);
            border-radius: var(--r-md);
            box-shadow: var(--shadow);
            padding: var(--s-5);
            font-family: "Source Serif 4", Georgia, serif;
            font-size: 17px;
            line-height: 1.7;
            color: var(--ink-1);
            max-width: 80ch;
            margin: 0;
            width: 100%;
            height: calc(100vh - 70px - 150px - var(--s-4) * 2);
            overflow-y: auto;
            position: relative;
        }
        
        /* Academic paragraph styling */
        .analysis p {
            margin: 0 0 var(--s-3);
            text-align: justify;
            text-rendering: optimizeLegibility;
            font-feature-settings: "liga","clig","kern";
        }
        
        /* Strong emphasis for academic terms */
        .analysis strong {
            font-weight: 700;
            color: var(--ink-1);
        }
        

        
        /* Italics for book titles and emphasis */
        .analysis em {
            font-style: italic;
            color: var(--ink-1);
        }
        
        /* Textual variants table styling */
        .variant-table {
            width: 100%;
            border-collapse: collapse;
            margin: var(--s-3) 0;
            font-size: 14px;
        }
        
        .variant-table th,
        .variant-table td {
            border: 1px solid var(--line);
            padding: var(--s-2);
            text-align: left;
            vertical-align: top;
        }
        
        .variant-table th {
            background: var(--panel);
            font-weight: 600;
            color: var(--ink-1);
        }
        
        .variant-table td {
            color: var(--ink-1);
        }
        
        .variant-table td:first-child {
            font-weight: 600;
            width: 25%;
        }
        
        .variant-table td:nth-child(2) {
            width: 30%;
            font-style: italic;
        }
        
        .variant-table td:nth-child(3) {
            width: 45%;
        }

        /* Meta line (play · act · scene · word count) */
        .analysis .meta {
            font-family: Inter, system-ui, sans-serif;
            font-size: 13px;
            letter-spacing: .02em;
            color: var(--ink-3);
            margin-bottom: var(--s-3);
        }

        /* ====== Section Headings ====== */

        /* Section headings (all levels) - unified styling */
        .analysis h3,
        .analysis .section-label {
            font-family: Inter, system-ui, sans-serif;
            font-weight: 700;
            font-size: 16px;
            color: var(--ink-1);
            margin: var(--s-4) 0 var(--s-2);
            border-bottom: 1px solid var(--line);
            padding-bottom: var(--s-1);
            display: block;
        }

        /* Subheadings inside numbered sections */
        .analysis h4 {
            font-family: Inter, system-ui, sans-serif;
            font-weight: 500;
            font-size: 14px;
            color: var(--ink-3);
            margin: var(--s-3) 0 var(--s-1);
        }

        /* ====== Paragraph & Lists ====== */

        /* Standard paragraph spacing */
        .analysis p {
            margin: 0 0 var(--s-3);
        }

        /* "Label — content" paragraphs (e.g., Plain-Language Paraphrase — …)  */
        .analysis .kv { 
            margin: 0 0 var(--s-3); 
        }
        .analysis .kv .k {
            font-family: Inter, system-ui, sans-serif;
            font-weight: 600;
            font-size: 15px;
            color: var(--ink-2);
            margin-right: .35rem;
        }
        .analysis .kv .sep { 
            margin-right: .35rem; 
            color: var(--ink-3); 
        } /* the em-dash */

        /* Key Words as definition list */
        .analysis dl {
            margin: 0 0 var(--s-3);
        }
        .analysis dt {
            font-family: Inter, system-ui, sans-serif;
            font-weight: 600;
            color: var(--ink-2);
            display: inline;
        }
        .analysis dd {
            display: inline;
            margin: 0 0 0 .35rem;
            color: var(--ink-1);
        }
        .analysis dd + dt::before {
            content: "\A"; /* new line for each term */
            white-space: pre;
        }

        /* Bullet lists */
        .analysis ul {
            margin: 0 0 var(--s-3);
            padding-left: 1.1rem;
        }
        .analysis ul li {
            margin: .2rem 0;
        }
        .analysis ul li::marker {
            color: var(--ink-3);
        }

        /* Reference lists */
        .analysis .ref-list {
            margin: 0;
            padding-left: 1.1rem;
            font-size: 15px;
        }
        .analysis .ref-list li {
            margin-bottom: .3rem;
        }
        .analysis .ref-list cite {
            font-style: italic;
            color: var(--ink-1);
        }
        .analysis .ref-list span {
            color: var(--ink-3);
        }

        /* ====== Dividers ====== */
        .analysis .section + .section,
        .analysis h3 + p {
            border-top: 1px solid var(--line);
            padding-top: var(--s-4);
            margin-top: var(--s-4);
        }

        /* ====== Microtypography ====== */
        .analysis p, .analysis li {
            text-rendering: optimizeLegibility;
            font-feature-settings: "liga","clig","kern";
        }

        /* ====== Compact mode for very long responses ====== */
        .analysis.compact {
            font-size: 16.5px;
            line-height: 1.55;
            max-width: 86ch;
        }

        /* Copy chip in the corner */
        .analysis .copy-chip {
            position: absolute;
            top: var(--s-3);
            right: var(--s-3);
            font-family: Inter, system-ui, sans-serif;
            font-size: 13px;
            color: var(--ink-2);
            background: var(--surface);
            border: 1px solid var(--line);
            border-radius: 999px;
            padding: 6px 10px;
            box-shadow: var(--shadow);
            cursor: pointer;
        }

        /* Quotes / citations inside the answer */
        .analysis blockquote {
            margin: var(--s-3) 0;
            padding-left: 1rem;
            border-left: 3px solid var(--line);
            color: var(--ink-2);
            font-style: italic;
        }



        .explain-btn {
            background: #000000;
            color: white;
            border: 2px solid white;
            border-radius: var(--r-md);
            padding: 10px 16px;
            font-family: var(--ui);
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
            white-space: nowrap;
            animation: flashBorder 2s infinite;
        }

        .explain-btn:hover {
            background: #333333;
            border-color: #ffffff;
        }

        .explain-btn:active {
            background: #1a1a1a;
            transform: translateY(1px);
        }

        @keyframes flashBorder {
            0%, 100% {
                border-color: white;
                box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            }
            50% {
                border-color: #ffffff;
                box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
            }
        }

        .instruction-text {
            color: var(--ink-3);
            font-family: var(--ui);
            font-size: 14px;
            line-height: 1.4;
            white-space: nowrap;
        }

        .analysis p {
            margin-bottom: var(--s-3);
            text-rendering: optimizeLegibility;
            font-feature-settings: "liga", "clig", "kern";
        }

        .analysis ul, .analysis ol {
            padding-left: 1.2rem;
            margin-bottom: var(--s-3);
        }

        .analysis-section + .analysis-section {
            border-top: 1px solid var(--line);
            padding-top: var(--s-4);
            margin-top: var(--s-4);
        }

        /* Analysis panel specific elements */
        .analysis .segment {
            margin-bottom: var(--s-4);
        }

        .analysis .analysis-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--s-2);
        }

        .analysis .analysis-title {
            font-family: Inter, system-ui, sans-serif;
            font-weight: 600;
            font-size: 16px;
            color: var(--ink-1);
        }

        .analysis .selection-info {
            font-family: Inter, system-ui, sans-serif;
            font-size: 14px;
            color: var(--ink-3);
            margin-bottom: var(--s-3);
        }

        .analysis .copy-btn {
            background: transparent;
            border: 1px solid var(--line);
            border-radius: var(--r-sm);
            padding: 6px 12px;
            font-size: 12px;
            color: var(--ink-2);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .analysis .copy-btn:hover {
            background: var(--panel);
            color: var(--ink-1);
        }

        /* Researching animation */
        .researching {
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        /* Analyzing message styling */
        .analyzing-message {
            font-family: Inter, system-ui, sans-serif;
            font-size: 20px;
            line-height: 1.6;
            color: var(--ink-1);
            text-align: center;
            margin: 40px 0;
            font-weight: 500;
        }



        .analysis .follow-up-input {
            display: flex;
            gap: var(--s-2);
            margin-top: var(--s-2);
        }

        .analysis .follow-up-input input {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid var(--line);
            border-radius: var(--r-sm);
            font-family: Inter, system-ui, sans-serif;
            font-size: 14px;
        }

        .analysis .follow-up-input input:focus {
            border-color: var(--accent);
            outline: none;
            box-shadow: 0 0 0 3px rgba(59,130,246,.15);
        }

        /* Ask button styling */
        .ask-btn {
            border-radius: 999px;
            font-weight: 600;
            padding: 8px 16px;
            background: #000000;
            border: none;
            color: #fff;
            transition: background-color 0.15s ease, transform 0.08s ease;
        }

        .ask-btn:hover {
            background: #333333;
        }

        .ask-btn:active {
            transform: translateY(1px);
            background: #1a1a1a;
        }

        /* Base style for all link buttons */
        .link-btn {
            display: block;
            width: 100%;
            padding: 10px 14px;
            border-radius: var(--r-md);
            font-size: 14px;
            font-weight: 500;
            text-align: left;
            color: var(--ink-1);
            transition: background-color 0.15s ease, color 0.15s ease, box-shadow 0.15s ease;
            border: 1px solid var(--line);
        }

        /* Default neutral for non-branded links */
        .link-btn.default {
            background: var(--panel);
        }

        .link-btn.default:hover {
            background: #E8EAED;
        }

        /* All link buttons use default grey styling */
        .link-btn.youtube,
        .link-btn.jstor,
        .link-btn.scholar,
        .link-btn.ise {
            background: var(--panel);
            border-color: var(--border);
            color: var(--ink-1);
        }

        .link-btn.youtube:hover,
        .link-btn.jstor:hover,
        .link-btn.scholar:hover,
        .link-btn.ise:hover {
            background: #E8EAED;
        }

        /* AI Analysis Content */
        .ai-analysis-content {
            background: white;
            padding: 20px;
            margin: 0;
            border-radius: 0;
            box-shadow: none;
            border: none;
        }

        /* Media Section */
        .media-section {
            background: white;
            padding: 20px;
            border-top: 1px solid rgba(0,0,0,0.08);
            margin: 0;
        }

        .media-links {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
        }

        .list a {
            display: block;
            padding: 10px 12px;
            border-radius: 10px;
            color: var(--ink-2);
            text-decoration: none;
            font-family: var(--ui);
            font-size: 14px;
            transition: background-color 0.2s ease;
        }

        .list a:hover {
            background: #EFF2F7;
            color: var(--ink-1);
        }

        .media-actions {
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
        }

        .research-actions {
            display: flex;
            flex-direction: column;
            gap: var(--s-2);
        }

        /* Empty State */
        .reader .empty {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: calc(100vh - 70px - 150px - var(--s-4) * 2);
            margin: 0;
            padding: 0;
        }

        .empty-body {
            display: flex;
            flex-direction: column;
            gap: var(--s-3);
            align-items: center;
            text-align: center;
        }

        .empty-title {
            font-weight: 700;
            font-family: Inter, system-ui, sans-serif;
        }

        .empty-sub {
            color: var(--ink-3);
            font-family: var(--ui);
        }

        /* Spacing/rhythm cleanup */
        .panel > * + * {
            margin-top: var(--s-3);
        }

        .section > * + * {
            margin-top: var(--s-2);
        }

        /* Research Section */
        .research-section {
            background: white;
            padding: 20px;
            border-top: 1px solid rgba(0,0,0,0.08);
            margin: 0;
        }

        .research-links {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
        }

        .research-link {
            color: #3B82F6;
            text-decoration: underline;
            font-size: 14px;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .research-link:hover {
            color: #2563EB;
        }

        .card {
            background: var(--surface);
            border: 1px solid var(--line);
            border-radius: var(--r-sm);
            padding: var(--s-4);
            box-shadow: var(--shadow);
            margin: 0;
        }

        .card h3 {
            font-weight: 600;
            color: var(--ink-2);
            margin: 0 0 var(--s-2);
        }

        .analysis-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .analysis-title {
            font-weight: 600;
            font-size: 16px;
            color: #2d3748;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        .copy-btn {
            background: none;
            border: 1px solid #ced4da;
            color: #6c757d;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }

        .copy-btn:hover {
            background: #f8f9fa;
        }

        .selection-info {
            font-size: 14px;
            color: #6c757d;
            margin-bottom: 15px;
        }

        .analysis-content {
            font-size: 14px;
            line-height: 1.7;
            color: #2d3748;
            font-family: Inter, system-ui, sans-serif;
        }

        .analysis-content p {
            margin-bottom: 15px;
        }

        .analysis-section h4 {
            font-size: 16px;
            font-weight: 700;
            color: #1a202c;
            margin: 20px 0 10px 0;
            font-family: Inter, system-ui, sans-serif;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 5px;
        }

        .analysis-section h4:first-of-type {
            margin-top: 0;
        }

        .quoted-text {
            background: #f8f9fa;
            border-left: 3px solid #007bff;
            padding: 10px 15px;
            margin: 15px 0;
            font-style: italic;
        }

        .follow-up-section {
            background: white;
            padding: 20px;
            border-top: 1px solid rgba(0,0,0,0.08);
            border-radius: 0 0 6px 6px;
            margin-top: 0;
        }

        .follow-up-input {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .follow-up-input input {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-family: inherit;
            font-size: 14px;
        }



        /* Responsive Design */
        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 250px 1fr 350px;
            }
        }

        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
                height: auto;
            }
            
            .left-panel, .right-panel {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <h1>Shakespeare Digital Variorum</h1>
        <div class="header-nav">
            <button class="nav-btn" onclick="openSettings()">Settings</button>
            <button class="nav-btn" onclick="openAbout()">About</button>
            <button class="explain-btn" onclick="explainHighlighted()">Explain Highlighted Text</button>
            <span class="instruction-text">Use your cursor to highlight text in the play, then click this button for analysis.</span>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Settings</div>
                <button class="modal-close" onclick="closeSettings()">&times;</button>
            </div>
            
            <div class="modal-body">
                <div class="upload-section">
                    <h3>Add Play to Library</h3>
                    
                    <!-- Single Play Upload -->
                    <div class="single-upload">
                        <h4>Upload Single Play</h4>
                        <div class="file-upload">
                            <input type="file" id="playFile" accept=".txt" onchange="handleFileUpload(event)">
                                                         <label for="playFile">Choose a play file (.txt)</label>
                                                          <div class="upload-instructions">
                                  Upload .txt files containing Shakespeare play text. The system will display the text exactly as it appears in your file.
                              </div>
                        </div>
                        <div class="play-name-section" id="playNameSection" style="display: none;">
                            <label for="playNameInput">Name of play:</label>
                            <div class="input-group">
                                <input type="text" id="playNameInput" placeholder="Enter play name (e.g., Hamlet, Romeo and Juliet)" class="play-input">
                                <button onclick="addPlayToLibrary();" class="add-btn" id="addPlayBtn" style="cursor: pointer;">Add Play</button>
                                <button onclick="cancelUpload();" class="cancel-btn" style="cursor: pointer;">Cancel</button>
                            </div>
                            <div class="name-instructions">
                                The system detected the play name above. You can modify it if needed, then click "Add Play" to add it to your library.
                            </div>
                        </div>
                        
                        <div class="upload-success" id="uploadSuccess">
                            ✅ Play uploaded successfully! You can now select it from the Library dropdown.
                        </div>
                    </div>
                    
                    <!-- Bulk Upload -->
                    <div class="bulk-upload">
                        <h4>Bulk Upload Multiple Plays</h4>
                        <div class="file-upload">
                            <input type="file" id="bulkPlayFiles" accept=".txt" multiple onchange="handleBulkUpload(event)">
                            <label for="bulkPlayFiles">Choose multiple play files (.txt)</label>
                            <div class="upload-instructions">
                                Select multiple TEISimple XML files (with MorphAdorner annotations) or .txt files to upload several plays at once with enhanced linguistic analysis.
                            </div>
                        </div>
                    </div>
                    
                    <div class="upload-error" id="uploadError">
                        ❌ Error uploading play. Please try again.
                    </div>
                </div>
                
                <!-- Library Management Section -->
                <div class="library-section">
                    <h3>Manage Library</h3>
                    <div class="library-plays" id="libraryPlays">
                        <!-- Library plays will appear here -->
                    </div>
                </div>
                
                <!-- Cache Management Section -->
                <div class="cache-section">
                    <h3>Cache Management</h3>
                    <div class="cache-info">
                        <p>AI analysis results are cached locally to improve performance. Cache expires after 30 days and is limited to 50 entries.</p>
                        <div class="cache-stats" id="cacheStats">
                            <!-- Cache stats will be populated here -->
                        </div>
                    </div>
                    <div class="cache-actions">
                        <button class="btn btn-ghost" onclick="clearAllCacheAndUpdate()">Clear All Cache</button>
                        <button class="btn btn-ghost" onclick="clearExpiredCache()">Clear Expired Entries</button>
                    </div>
                </div>
                
                <!-- Close Button -->
                <div class="modal-footer">
                    <button class="close-settings-btn" onclick="closeSettings()">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- About Modal -->
    <div id="aboutModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">About This Project</div>
                <button class="modal-close" onclick="closeAbout()">&times;</button>
            </div>
            
            <div class="modal-body">
                <div class="about">
                    <p>The New Variorum Shakespeare editions have been the gold standard of Shakespearean scholarship for over a century, bringing together the most important critical commentary, textual analysis, and historical context in comprehensive annotated volumes. The Shakespeare Digital Variorum builds on this tradition, harnessing the power of artificial intelligence to make centuries of scholarly insight accessible to everyone, from high school students to veteran researchers.</p>
                    
                    <p>Our platform integrates authoritative texts based on the Folger Shakespeare Library editions of each play, with commentary from major variorum editions, scholarly databases, and historical sources. We include references to film adaptations, stage productions, and cultural interpretations that show how Shakespeare's works have lived and evolved across different media and eras. Using advanced AI, we can instantly provide plain-language explanations of complex passages, trace the etymology of Early Modern English words as they appear in context, analyze prosodic patterns across scenes and plays, and illuminate the historical events and cultural forces that shaped each work.</p>
                    
                    <p>The goal is radical accessibility. Whether you're encountering Hamlet's soliloquies for the first time or you're a seasoned scholar investigating textual variants, the Shakespeare Digital Variorum meets you where you are. Students can receive immediate clarification of archaic language and historical references. Researchers can discover thematic connections across the complete canon. Theater practitioners can access centuries of performance history, from Garrick to Branagh to contemporary productions worldwide.</p>
                    
                    <p>We believe Shakespeare belongs to everyone, not just academics. By connecting scholarly commentary with film clips, performance videos, and multimedia resources, we show how these 400-year-old plays continue to speak to modern audiences. A teenager reading Romeo and Juliet can instantly see how Baz Luhrmann reimagined the balcony scene, while a graduate student can access the full textual apparatus from multiple critical editions.</p>
                    
                    <p>This isn't about replacing human scholarship but about democratizing it. Every AI-generated insight is grounded in the work of generations of Shakespeare scholars, from the earliest editors to contemporary critics. We've simply made it possible for anyone to access that collective wisdom instantly, searchably, and in conversation with the texts themselves.</p>
                    
                    <p>The Shakespeare Digital Variorum represents the next evolution of the variorum tradition: comprehensive, scholarly, and designed for universal access. Shakespeare's world is vast, and now everyone can explore all of it.</p>
                    
                    <p><em>Created by Jack David Carson, Massachusetts Institute of Technology • 2025</em></p>

                    <div class="meta">
                        <div class="badge">Version <strong>1.0.0</strong></div>
                        <div class="badge">Build <span id="build-id">auto</span></div>
                        <div class="badge">Texts: Folger base</div>
                        <div class="badge">Commentary: NVSh + secondary</div>
                    </div>

                    <h2>Purpose</h2>
                    <p>Bring variorum-grade scholarship to a modern, accessible reading tool powered by AI.</p>

                    <h2>What's inside</h2>
                    <ul>
                        <li>Authoritative texts (Folger editions).</li>
                        <li>Cross-references to major variorum editions and scholarly databases.</li>
                        <li>AI explanations, paraphrase, performance notes, and research links.</li>
                    </ul>

                    <div class="callout">
                        We do not replace editors. AI outputs are aids; verify before citing.
                    </div>

                    <h2>Sources & Attribution</h2>
                    <ul>
                        <li>Texts: Based on the Folger Shakespeare Library editions, edited by Barbara Mowat, Paul Werstine, Michael Poston, and Rebecca Niles</li>
                    </ul>

                    <h2>Contact & License</h2>
                    <p>Issues or corrections: <a href="mailto:jack@example.com">email</a>. License: CC BY-NC-SA 4.0 - Free to use for non-commercial, educational purposes with attribution.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Rights & Attribution Modal -->
    <div id="rightsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Rights & Attribution</div>
                <span class="close" onclick="closeRights()">&times;</span>
            </div>
            
            <div class="modal-body">
                <div class="rights-content">
                    <h4>Shakespeare Texts</h4>
                    <p>Public domain. Based on editions from the Folger Shakespeare Library and other scholarly sources.</p>
                    
                    <h4>Scholarly Commentary</h4>
                    <p>Used under fair use for educational purposes. Sources include JSTOR, academic publications, and historical editions. Full citations provided with each annotation.</p>
                    
                    <h4>This Website</h4>
                    <p>Licensed under CC BY-NC-SA 4.0 - Free to use for non-commercial, educational purposes with attribution.</p>
                    
                    <h4>AI Analysis</h4>
                    <p>Generated content is provided for educational purposes. Users should verify information with primary sources.</p>
                    
                    <div class="rights-footer">
                        <h4>Shakespeare Digital Variorum</h4>
                        <p>Created by Jack David Carson, Massachusetts Institute of Technology • 2025</p>
                        <p>Questions about usage? Contact: <a href="mailto:jdcarson@mit.edu">jdcarson@mit.edu</a></p>
                        <button class="close-rights-btn" onclick="closeRights()">Close</button>
                    </div>
                </div>
            </div>
        </div>
    </div>



    <!-- Main Content -->
    <div class="layout">
        <!-- Sidebar -->
        <aside class="sidebar" aria-label="Play navigation">
            <div class="section-title">Library</div>
            <div class="play-selector-container">
                <select class="play-selector" id="playSelector">
                    <option value="" disabled selected>Choose a Play</option>
                </select>
                <button onclick="loadSelectedPlay()" class="go-btn">Go</button>
            </div>

            <ul class="navigation-list" id="navigationList" aria-label="Play navigation">
                <!-- Navigation will be populated dynamically -->
            </ul>
        </aside>

        <!-- Reading Pane -->
        <div class="reader panel play" id="playText">
            <div class="empty">
                <div class="empty-body">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#6B7078" stroke-width="1.5"><circle cx="12" cy="12" r="9"/><path d="M8 13h8M8 10h5"/></svg>
                    <div class="empty-title">Add a play to begin</div>
                    <div class="empty-sub">Upload a text file in Settings. We'll auto-index acts and scenes.</div>
                    <button class="btn btn-primary" onclick="openSettings()">Open Settings</button>
                </div>
            </div>

        </div>

        <!-- Analysis Pane -->
        <div class="analysis panel" id="analysisPanel">
            <!-- Analysis Mode Selector -->
            <div class="segment">
                <button onclick="setAnalysisMode('basic')" aria-pressed="true">Basic</button>
                <button onclick="setAnalysisMode('intermediate')" aria-pressed="false">Intermediate</button>
                <button onclick="setAnalysisMode('expert')" aria-pressed="false">Expert</button>
                <button onclick="setAnalysisMode('fullfathomfive')" aria-pressed="false">Full Fathom Five</button>
            </div>

            <!-- AI Analysis Content -->
            <div class="analysis-header">
                <div class="analysis-title">Basic Analysis</div>
                <button class="copy-btn" onclick="copyAnalysis()">Copy</button>
            </div>
            <div class="meta">No play loaded</div>
            <div class="analysis-content">
                <p>Highlight text in the play to get AI-powered analysis.</p>
            </div>

            <!-- Media Section -->
            <h3>Media</h3>
            <div class="media-actions">
                <button class="link-btn youtube" onclick="searchYouTube('scene')">Search YouTube for this scene</button>
            </div>

            <!-- Research Section -->
            <h3>Research</h3>
            <div class="research-actions">
                <button class="link-btn jstor" onclick="searchJSTOR('exact')">Search JSTOR for exact quotation</button>
                <button class="link-btn jstor" onclick="searchJSTOR('passage')">Search JSTOR for this passage/scene</button>
                <button class="link-btn scholar" onclick="searchGoogleScholar()">Google Scholar</button>
                <button class="link-btn ise" onclick="openInternetShakespeare()">Internet Shakespeare Editions</button>
            </div>

            <!-- Follow-up Section -->
            <h3>Ask a follow-up question</h3>
            <div class="follow-up-input">
                <input type="text" placeholder="Ask a follow-up question..." id="followUpQuestion">
                <button class="ask-btn" onclick="askFollowUp()">Ask</button>
            </div>
        </div>
    </div>



    <script>
        let selectedText = '';
        let plays = {};
        let currentPlay = '';
        let currentScene = '';
        
        // Cache management
        const CACHE_VERSION = '1.0';
        const CACHE_EXPIRY_DAYS = 30;
        const MAX_CACHE_SIZE = 50; // Maximum number of cached items

        // Modal functions
        function openSettings() {
            document.getElementById('settingsModal').style.display = 'block';
            
            // Hide any existing success/error messages when opening settings
            document.getElementById('uploadSuccess').style.display = 'none';
            document.getElementById('uploadError').style.display = 'none';
            
            updateLibraryPlays(); // Refresh the library display
            updateCacheStats(); // Update cache statistics
        }

        function closeSettings() {
            console.log('closeSettings called');
            const modal = document.getElementById('settingsModal');
            console.log('Settings modal element:', modal);
            if (modal) {
                modal.style.display = 'none';
                console.log('Settings modal hidden');
            } else {
                console.error('Settings modal not found');
            }
        }

        function openAbout() {
            document.getElementById('aboutModal').style.display = 'block';
        }

        function closeAbout() {
            document.getElementById('aboutModal').style.display = 'none';
        }

        function openRights() {
            document.getElementById('rightsModal').style.display = 'block';
        }

        function closeRights() {
            document.getElementById('rightsModal').style.display = 'none';
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const settingsModal = document.getElementById('settingsModal');
            const aboutModal = document.getElementById('aboutModal');
            const rightsModal = document.getElementById('rightsModal');
            if (event.target === settingsModal) {
                closeSettings();
            }
            if (event.target === aboutModal) {
                closeAbout();
            }
            if (event.target === rightsModal) {
                closeRights();
            }
        }

        // Settings navigation functionality
        document.addEventListener('DOMContentLoaded', function() {
            // Add ARIA attributes to modals
            const settingsModal = document.getElementById('settingsModal');
            const aboutModal = document.getElementById('aboutModal');
            
            if (settingsModal) {
                settingsModal.setAttribute('role', 'dialog');
                settingsModal.setAttribute('aria-modal', 'true');
                settingsModal.setAttribute('aria-labelledby', 'settings-modal-title');
            }
            
            if (aboutModal) {
                aboutModal.setAttribute('role', 'dialog');
                aboutModal.setAttribute('aria-modal', 'true');
                aboutModal.setAttribute('aria-labelledby', 'about-modal-title');
            }

            // Settings nav switching
            document.querySelectorAll('.settings-nav .item').forEach((el, i) => {
                el.addEventListener('click', () => {
                    document.querySelectorAll('.settings-nav .item').forEach(n => n.classList.remove('active'));
                    el.classList.add('active');
                    // For now, just highlight the active nav item
                    // In a full implementation, you'd show different panes
                });
            });

            // Escape key to close modals
            document.addEventListener('keydown', e => {
                if (e.key === 'Escape') {
                    if (settingsModal && settingsModal.style.display === 'block') {
                        closeSettings();
                    }
                    if (aboutModal && aboutModal.style.display === 'block') {
                        closeAbout();
                    }
                }
            });
        });

        // Detect play title from content and return in proper case
        function detectPlayTitle(content) {
            const lines = content.split('\n');
            
            // Common Shakespeare play titles for better matching
            const shakespeareTitles = [
                'HAMLET', 'ROMEO AND JULIET', 'MACBETH', 'KING LEAR', 'OTHELLO', 'A MIDSUMMER NIGHT\'S DREAM',
                'THE TEMPEST', 'AS YOU LIKE IT', 'TWELFTH NIGHT', 'MUCH ADO ABOUT NOTHING', 'THE MERCHANT OF VENICE',
                'JULIUS CAESAR', 'ANTONY AND CLEOPATRA', 'CORIOLANUS', 'TITUS ANDRONICUS', 'CYMBELINE',
                'THE WINTER\'S TALE', 'PERICLES', 'THE TWO GENTLEMEN OF VERONA', 'THE COMEDY OF ERRORS',
                'LOVE\'S LABOUR\'S LOST', 'A MIDSUMMER NIGHT\'S DREAM', 'THE TAMING OF THE SHREW',
                'ALL\'S WELL THAT ENDS WELL', 'MEASURE FOR MEASURE', 'TROILUS AND CRESSIDA',
                'TIMON OF ATHENS', 'KING JOHN', 'RICHARD II', 'HENRY IV, PART 1', 'HENRY IV, PART 2',
                'HENRY V', 'HENRY VI, PART 1', 'HENRY VI, PART 2', 'HENRY VI, PART 3', 'RICHARD III',
                'HENRY VIII', 'THE TWO NOBLE KINSMEN'
            ];
            
            // Look for the actual play title in the first 50 lines
            for (let i = 0; i < Math.min(50, lines.length); i++) {
                const line = lines[i].trim().toUpperCase();
                if (line && line.length > 0) {
                    // Skip common headers and stage directions
                    if (line.includes('DRAMATIS') || line.includes('ACT') || line.includes('SCENE') || 
                        line.includes('BY WILLIAM SHAKESPEARE') || line.includes('CHARACTERS') ||
                        line.startsWith('[') || line.startsWith('_') || line.length < 3) {
                        continue;
                    }
                    
                    // Check if this line matches a known Shakespeare title
                    for (const title of shakespeareTitles) {
                        if (line.includes(title) || title.includes(line)) {
                            return titleToProperCase(title);
                        }
                    }
                    
                    // Look for title patterns (all caps, reasonable length, no special characters)
                    if (line.match(/^[A-Z\s,]+$/) && line.length > 3 && line.length < 50) {
                        // Additional check: make sure it's not a character name
                        if (!line.includes('PRINCE') && !line.includes('KING') && !line.includes('QUEEN') &&
                            !line.includes('DUKE') && !line.includes('LORD') && !line.includes('LADY') &&
                            !line.includes('SIR') && !line.includes('CAPTAIN') && !line.includes('GENTLEMAN')) {
                            return titleToProperCase(line);
                        }
                    }
                }
            }
            
            // Fallback to filename
            return 'Unknown Play';
        }

        // Convert title to proper case
        function titleToProperCase(title) {
            // Convert to title case with proper handling of articles and prepositions
            const words = title.toLowerCase().split(' ');
            const articles = ['a', 'an', 'the', 'of', 'in', 'on', 'at', 'to', 'for', 'with', 'by'];
            
            return words.map((word, index) => {
                // Always capitalize first and last word
                if (index === 0 || index === words.length - 1) {
                    return word.charAt(0).toUpperCase() + word.slice(1);
                }
                // Capitalize articles and prepositions only if they're longer than 3 characters
                if (articles.includes(word) && word.length <= 3) {
                    return word;
                }
                // Capitalize all other words
                return word.charAt(0).toUpperCase() + word.slice(1);
            }).join(' ');
        }

        // Add play to library
        function addPlayToLibrary() {
            console.log('=== ADD PLAY BUTTON CLICKED ===');
            try {
                console.log('addPlayToLibrary function called');
                
                const playNameInput = document.getElementById('playNameInput');
                if (!playNameInput) {
                    console.error('playNameInput element not found');
                    return;
                }
                
                const playName = playNameInput.value.trim();
                console.log('Play name:', playName);
                console.log('Temp play data:', window.tempPlayData);
                
                if (!playName) {
                    return;
                }
                
                if (!window.tempPlayData) {
                    return;
                }
            
            // Parse the play text and add to library
            const fileName = window.tempPlayData.fileName;
            console.log('Calling parsePlayText with:', fileName, 'content length:', window.tempPlayData.content.length, 'playName:', playName);
            
            try {
                console.log('Starting parsePlayText...');
                parsePlayText(fileName, window.tempPlayData.content, playName);
                console.log('parsePlayText completed successfully');
                console.log('Plays object after parsing:', plays);
                console.log('Number of plays:', Object.keys(plays).length);
            } catch (parseError) {
                console.error('Error in parsePlayText:', parseError);
                alert('Error parsing play: ' + parseError.message);
                return;
            }
            
            // Simple synchronous approach
            try {
                console.log('Starting updatePlaySelector...');
                updatePlaySelector();
                console.log('updatePlaySelector completed');
            } catch (selectorError) {
                console.error('Error in updatePlaySelector:', selectorError);
                alert('Error updating play selector: ' + selectorError.message);
                return;
            }
            
            try {
                console.log('Starting updateLibraryPlays...');
                updateLibraryPlays();
                console.log('updateLibraryPlays completed');
            } catch (libraryError) {
                console.error('Error in updateLibraryPlays:', libraryError);
                alert('Error updating library: ' + libraryError.message);
                return;
            }
            
            // Complete the process
            completeAddPlayProcess(fileName, playName);
            
        } catch (error) {
            console.error('Error in addPlayToLibrary:', error);
            alert('Error adding play to library: ' + error.message);
        }
        }

        // Complete the add play process
        function completeAddPlayProcess(fileName, playName) {
            try {
                console.log('completeAddPlayProcess started');
                console.log('Completing add play process...');
                
                // Clear temporary data
                window.tempPlayData = null;
                
                // Hide the name input section
                const nameSection = document.getElementById('playNameSection');
                if (nameSection) {
                    nameSection.style.display = 'none';
                }
                
                // Show the upload section again
                const uploadSection = document.querySelector('.single-upload .file-upload');
                if (uploadSection) {
                    uploadSection.style.display = 'block';
                }
                
                // Clear the file input
                const fileInput = document.getElementById('playFile');
                if (fileInput) {
                    fileInput.value = '';
                }
                
                // Show success message
                const successMsg = document.getElementById('uploadSuccess');
                if (successMsg) {
                    successMsg.style.display = 'block';
                    successMsg.textContent = `✅ "${playName}" has been included in your library!`;
                }
                
                // Auto-select the new play
                const selector = document.getElementById('playSelector');
                if (selector) {
                    selector.value = fileName;
                }
                
                // Load the play (use fileName as the key)
                console.log('Loading play with fileName key:', fileName);
                console.log('Available play keys:', Object.keys(plays));
                console.log('Play object for fileName:', plays[fileName]);
                
                // Temporarily disable loadPlay to test if it's causing the hang
                console.log('Skipping loadPlay for now to test completion');
                // loadPlay(fileName);
                
                console.log('Add play process completed successfully!');
                // Success message is already shown above, now close settings
                setTimeout(() => {
                    closeSettings();
                }, 1500); // Close after 1.5 seconds to show success message
            } catch (error) {
                console.error('Error completing add play process:', error);
                alert('Error completing process: ' + error.message);
            }
        }

        // Cancel upload and reset to initial state
        function cancelUpload() {
            // Hide the name input section
            document.getElementById('playNameSection').style.display = 'none';
            
            // Show the upload section again
            const uploadSection = document.querySelector('.single-upload .file-upload');
            if (uploadSection) {
                uploadSection.style.display = 'block';
            }
            
            // Clear the file input
            const fileInput = document.getElementById('playFile');
            if (fileInput) {
                fileInput.value = '';
            }
            
            // Clear temporary data
            window.tempPlayData = null;
            
            // Hide any messages
            document.getElementById('uploadSuccess').style.display = 'none';
            document.getElementById('uploadError').style.display = 'none';
        }

        // File upload handling - text files only
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Check if it's a text file
            if (!file.name.toLowerCase().endsWith('.txt')) {
                alert('Please upload a .txt file only.');
                return;
            }

            // Hide any previous messages
            document.getElementById('uploadSuccess').style.display = 'none';
            document.getElementById('uploadError').style.display = 'none';

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    const fileName = file.name.replace('.txt', '');
                    
                    console.log('=== TEXT FILE UPLOAD ===');
                    console.log('File name:', file.name);
                    console.log('File size:', file.size, 'bytes');
                    console.log('Content length:', content.length, 'characters');
                    console.log('Lines in file:', content.split('\n').length);
                    console.log('=== END DEBUG ===');
                    
                    // Detect the play title from content
                    const detectedPlayName = detectPlayTitle(content);
                    
                    // Show the name input section
                    document.getElementById('playNameSection').style.display = 'block';
                    
                    // Hide the upload section to avoid confusion
                    const uploadSection = document.querySelector('.single-upload .file-upload');
                    if (uploadSection) {
                        uploadSection.style.display = 'none';
                    }
                    
                    // Populate the name input with the detected play name
                    document.getElementById('playNameInput').value = detectedPlayName;
                    
                    // Store the content temporarily for later use
                    window.tempPlayData = {
                        fileName: fileName,
                        content: content,
                        detectedName: detectedPlayName
                    };
                    
                    // Show success message
                    document.getElementById('uploadSuccess').style.display = 'block';
                    document.getElementById('uploadSuccess').textContent = `✅ Text file uploaded successfully! Review the play name and click "Add Play" to include it in your library.`;
                    
                } catch (error) {
                    console.error('Error processing file:', error);
                    document.getElementById('uploadError').style.display = 'block';
                }
            };
            
            reader.onerror = function() {
                document.getElementById('uploadError').style.display = 'block';
            };
            
            reader.readAsText(file);
        }

        // Bulk upload handling - text files only
        function handleBulkUpload(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;

            // Check if all files are text files
            const nonTextFiles = Array.from(files).filter(file => !file.name.toLowerCase().endsWith('.txt'));
            if (nonTextFiles.length > 0) {
                alert('Please upload only .txt files.');
                return;
            }

            // Hide any previous messages
            document.getElementById('uploadSuccess').style.display = 'none';
            document.getElementById('uploadError').style.display = 'none';

            // Store bulk upload data
            window.bulkUploadData = [];
            let processedCount = 0;

            Array.from(files).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const content = e.target.result;
                        const fileName = file.name.replace('.txt', '');
                        const detectedName = detectPlayTitle(content);
                        
                        // Store data for bulk processing
                        window.bulkUploadData.push({
                            fileName: fileName,
                            content: content,
                            detectedName: detectedName,
                            originalName: fileName
                        });
                        
                        processedCount++;
                        
                        // When all files are processed, show rename interface
                        if (processedCount === files.length) {
                            showBulkRenameInterface();
                        }
                        
                    } catch (error) {
                        console.error('Error processing file:', file.name, error);
                        processedCount++;
                        
                        if (processedCount === files.length) {
                            showBulkRenameInterface();
                        }
                    }
                };
                
                reader.onerror = function() {
                    console.error('Error reading file:', file.name);
                    processedCount++;
                    
                    if (processedCount === files.length) {
                        showBulkRenameInterface();
                    }
                };
                
                reader.readAsText(file);
            });
        }

        // Show bulk rename interface
        function showBulkRenameInterface() {
            const bulkSection = document.querySelector('.bulk-upload');
            
            // Create rename interface
            let renameHTML = '<div class="bulk-rename-section">';
            renameHTML += '<h4>Review and Rename Plays</h4>';
            renameHTML += '<div class="bulk-rename-list">';
            
            window.bulkUploadData.forEach((play, index) => {
                renameHTML += `
                    <div class="bulk-rename-item">
                        <label for="bulkName${index}">Play ${index + 1}:</label>
                        <input type="text" id="bulkName${index}" value="${play.detectedName}" class="bulk-name-input">
                        <span class="original-filename">(from: ${play.originalName})</span>
                    </div>
                `;
            });
            
            renameHTML += '</div>';
            renameHTML += '<button onclick="processBulkUpload()" class="add-btn">Add All Plays</button>';
            renameHTML += '</div>';
            
            // Replace bulk upload section content
            bulkSection.innerHTML = renameHTML;
        }

        // Process bulk upload with custom names
        function processBulkUpload() {
            let successCount = 0;
            let errorCount = 0;

            window.bulkUploadData.forEach((play, index) => {
                try {
                    const customName = document.getElementById(`bulkName${index}`).value.trim();
                    const playName = customName || play.detectedName;
                    
                    parsePlayText(play.fileName, play.content, playName);
                    successCount++;
                } catch (error) {
                    console.error('Error processing play:', play.fileName, error);
                    errorCount++;
                }
            });

            // Update UI
            updatePlaySelector();
            updateLibraryPlays();
            
            // Show success message (keep settings open)
            if (successCount > 0) {
                const successMsg = document.getElementById('uploadSuccess');
                successMsg.style.display = 'block';
                successMsg.textContent = `✅ Successfully uploaded ${successCount} play(s)!`;
            }
            
            if (errorCount > 0) {
                const errorMsg = document.getElementById('uploadError');
                errorMsg.style.display = 'block';
                errorMsg.textContent = `❌ ${errorCount} play(s) failed to upload.`;
            }
            
            // Clear bulk upload data
            window.bulkUploadData = null;
            
            // Reset bulk upload section
            resetBulkUploadSection();
            
            // Close settings after successful upload
            if (successCount > 0) {
                setTimeout(() => {
                    closeSettings();
                }, 1500); // Close after 1.5 seconds to show success message
            }
        }

        // Reset bulk upload section to original state
        function resetBulkUploadSection() {
            const bulkSection = document.querySelector('.bulk-upload');
            bulkSection.innerHTML = `
                <h4>Bulk Upload Multiple Plays</h4>
                <div class="file-upload">
                    <input type="file" id="bulkPlayFiles" accept=".txt" multiple onchange="handleBulkUpload(event)">
                    <label for="bulkPlayFiles">Choose multiple play files (.txt)</label>
                    <div class="upload-instructions">
                        Select multiple .txt files to upload several plays at once.
                    </div>
                </div>
            `;
        }

        // Simple parse play text - display exactly as uploaded
        function parsePlayText(fileName, content, customPlayName = null) {
            console.log('parsePlayText started - simple approach');
            
            // Use custom play name if provided, otherwise extract from content
            let actualPlayName = customPlayName || fileName;
            
            const play = {
                name: actualPlayName,
                originalFileName: fileName,
                characters: [],
                acts: {},
                scenes: {}
            };

            // Simple approach: just split by lines and find acts/scenes
            const lines = content.split('\n');
            let currentAct = '';
            let currentScene = '';
            let inScene = false;
            let characterSet = new Set(); // Track unique character names

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();
                if (!trimmedLine) continue;
                
                // Look for Act headers
                if (trimmedLine.match(/^ACT\s+[IVX0-9]+/i)) {
                    currentAct = trimmedLine;
                    play.acts[currentAct] = [];
                    inScene = false;
                    continue;
                }

                // Look for Scene headers
                if (trimmedLine.match(/^SCENE\s+[IVX0-9]+/i)) {
                    currentScene = `${currentAct} - ${trimmedLine}`;
                    play.scenes[currentScene] = [];
                    if (currentAct) {
                        play.acts[currentAct].push(currentScene);
                    }
                    inScene = true;
                    continue;
                }

                // Collect scene content and detect character names
                if (inScene && currentScene && trimmedLine) {
                    play.scenes[currentScene].push(line); // Store original line with spacing
                    
                    // Check if this line is a character name (all caps, reasonable length)
                    if (trimmedLine.match(/^[A-Z\s]+$/) && 
                        trimmedLine.length > 2 && 
                        trimmedLine.length < 50 && 
                        !trimmedLine.startsWith('[') && 
                        !trimmedLine.endsWith(']') &&
                        !trimmedLine.includes('ACT') &&
                        !trimmedLine.includes('SCENE')) {
                        characterSet.add(trimmedLine);
                    }
                }
            }
            
            // Convert character set to array
            play.characters = Array.from(characterSet).sort();

            plays[fileName] = play;
            console.log('Simple parsing completed for:', fileName);
            
            // Set as current play if it's the first one
            if (Object.keys(plays).length === 1) {
                currentPlay = fileName;
                try {
                    loadPlay(currentPlay);
                } catch (loadError) {
                    console.error('Error in loadPlay:', loadError);
                }
            }
        }

        // Simple pass-through - return lines exactly as they are
        function groupDialogueBySpeaker(lines) {
            return lines; // No processing, just return the lines as-is
        }

        // Alternative parsing method for plays that don't follow standard format
        function parsePlayTextAlternative(fileName, content, play) {
            const lines = content.split('\n');
            let currentAct = '';
            let currentScene = '';
            let inScene = false;

            console.log('Trying alternative parsing for:', fileName);

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                // Look for any line that might be an act (contains "ACT" or roman numerals)
                if (line.match(/ACT/i) || line.match(/^[IVX]+\./i) || line.match(/^[IVX]+\s*$/i)) {
                    console.log('Alternative: Found potential act at line', i, ':', line);
                    currentAct = line;
                    play.acts[currentAct] = [];
                    inScene = false;
                    continue;
                }

                // Look for any line that might be a scene (contains "SCENE" or numbers)
                if (line.match(/SCENE/i) || line.match(/^[0-9]+\./i) || line.match(/^[IVX]+\./i)) {
                    console.log('Alternative: Found potential scene at line', i, ':', line);
                    currentScene = `${currentAct} - ${line}`;
                    play.scenes[currentScene] = [];
                    if (currentAct) {
                        play.acts[currentAct].push(currentScene);
                    }
                    inScene = true;
                    continue;
                }

                // Collect scene content
                if (inScene && currentScene && line) {
                    play.scenes[currentScene].push(line);
                }
            }
            
            // Group dialogue by speaker for alternative parsing too
            Object.keys(play.scenes).forEach(sceneKey => {
                if (play.scenes[sceneKey].length > 0) {
                    play.scenes[sceneKey] = groupDialogueBySpeaker(play.scenes[sceneKey]);
                }
            });
        }



        // Update play selector dropdown
        function updatePlaySelector() {
            console.log('updatePlaySelector called');
            console.log('plays object:', plays);
            console.log('Number of plays:', Object.keys(plays).length);
            
            const selector = document.getElementById('playSelector');
            if (!selector) {
                console.error('playSelector element not found');
                return;
            }
            
            const currentValue = selector.value; // Remember current selection
            console.log('Current selector value:', currentValue);
            
            selector.innerHTML = '<option value="" disabled selected>Choose a Play</option>';
            
            const playKeys = Object.keys(plays);
            console.log('Total plays to add:', playKeys.length);
            
            // Sort plays alphabetically by name
            const sortedPlays = playKeys.sort((a, b) => {
                return plays[a].name.localeCompare(plays[b].name);
            });
            
            // Simple synchronous approach
            sortedPlays.forEach(playName => {
                console.log('Adding play to selector:', playName, 'with name:', plays[playName].name);
                const option = document.createElement('option');
                option.value = playName;
                option.textContent = plays[playName].name;
                selector.appendChild(option);
            });
            
            // Restore selection if it was valid
            if (currentValue && plays[currentValue]) {
                selector.value = currentValue;
                console.log('Restored selection to:', currentValue);
            }
            
            console.log('updatePlaySelector completed');
        }

        // Update library plays list
        function updateLibraryPlays() {
            console.log('updateLibraryPlays called');
            console.log('plays object:', plays);
            console.log('Number of plays:', Object.keys(plays).length);
            
            const container = document.getElementById('libraryPlays');
            if (!container) {
                console.error('libraryPlays element not found');
                return;
            }
            
            container.innerHTML = '';
            
            if (Object.keys(plays).length === 0) {
                container.innerHTML = '<p style="color: #6c757d; font-style: italic;">No plays in library yet.</p>';
                console.log('No plays to display');
                return;
            }
            
            // Sort plays alphabetically by name
            const sortedPlays = Object.keys(plays).sort((a, b) => {
                return plays[a].name.localeCompare(plays[b].name);
            });
            
            sortedPlays.forEach(playName => {
                const play = plays[playName];
                const playItem = document.createElement('div');
                playItem.className = 'library-item';
                
                const actCount = Object.keys(play.acts).length;
                const sceneCount = Object.keys(play.scenes).length;
                const characterCount = play.characters.length;
                
                playItem.innerHTML = `
                    <div>
                        <div class="library-name">${play.name}</div>
                        <div class="play-info">
                            ${actCount} act(s) • ${sceneCount} scene(s) • ${characterCount} character(s)
                        </div>
                    </div>
                    <button class="delete-play" onclick="deletePlay('${playName}')">Delete</button>
                `;
                container.appendChild(playItem);
            });
        }

        // Delete a play from library
        function deletePlay(playName) {
            if (confirm(`Are you sure you want to delete "${plays[playName].name}" from your library?`)) {
                delete plays[playName];
                updatePlaySelector();
                updateLibraryPlays();
                
                if (currentPlay === playName) {
                    currentPlay = '';
                    loadPlay('');
                }
                
                // Show success message
                document.getElementById('uploadSuccess').style.display = 'block';
                document.getElementById('uploadSuccess').textContent = `✅ Play deleted from library.`;
            }
        }

        // Load selected play from dropdown
        function loadSelectedPlay() {
            const selector = document.getElementById('playSelector');
            const selectedPlay = selector.value;
            if (selectedPlay) {
                loadPlay(selectedPlay);
            }
        }

        // Load a play
        function loadPlay(playName) {
            console.log('loadPlay called with:', playName);
            console.log('plays object keys:', Object.keys(plays));
            console.log('plays[playName]:', plays[playName]);
            console.log('playText element innerHTML before loadPlay:', document.getElementById('playText').innerHTML.substring(0, 200));
            
            const playTextElement = document.getElementById('playText');
            const navigationElement = document.getElementById('navigationList');
            
            console.log('playText element found:', playTextElement);
            console.log('navigation element found:', navigationElement);
            
            if (!playName || !plays[playName]) {
                console.log('Play not found or invalid:', playName);
                // Don't overwrite the default content if no play is loaded
                if (navigationElement) {
                    navigationElement.innerHTML = '';
                } else {
                    console.error('navigationList element not found!');
                }
                return;
            }

            const play = plays[playName];
            currentPlay = playName;
            
            console.log('Loading play:', playName, 'with acts:', Object.keys(play.acts));
            
            // Update navigation
            updateNavigation(play);
            
            // Load first scene automatically
            const firstAct = Object.keys(play.acts)[0];
            if (firstAct && play.acts[firstAct] && play.acts[firstAct].length > 0) {
                const firstScene = play.acts[firstAct][0];
                console.log('Loading first scene:', firstScene);
                loadScene(firstScene);
            } else {
                console.log('No scenes found, showing welcome message');
                // If no scenes found, show welcome message
                document.getElementById('playText').innerHTML = `
                    <div class="scene-title">${playName}</div>
                    <div class="scene-separator"></div>
                    <p>Play loaded successfully. Use the navigation to explore acts and scenes.</p>
                    <p><em>Debug: Found ${Object.keys(play.acts).length} acts</em></p>
                `;
                // Update meta line even when no scenes are found
                updateMetaLine();
            }
        }

        // Update navigation list
        function updateNavigation(play) {
            const navList = document.getElementById('navigationList');
            navList.innerHTML = '';
            
            console.log('Updating navigation for play:', play.name, play);
            
            // Add Dramatis Personae
            if (play.characters.length > 0) {
                const dramatisItem = document.createElement('li');
                dramatisItem.innerHTML = '<a href="#" onclick="showDramatisPersonae()">Dramatis Personae</a>';
                navList.appendChild(dramatisItem);
            }
            
            // Add Acts and Scenes
            Object.keys(play.acts).forEach(actName => {
                const actItem = document.createElement('li');
                actItem.innerHTML = `<a href="#" onclick="loadFirstSceneOfAct('${actName}')">${actName}</a>`;
                navList.appendChild(actItem);
                
                if (play.acts[actName] && play.acts[actName].length > 0) {
                    play.acts[actName].forEach(sceneName => {
                        const sceneItem = document.createElement('li');
                        sceneItem.className = 'sub-item';
                        sceneItem.innerHTML = `<a href="#" onclick="loadScene('${sceneName}')" data-scene="${sceneName}">${sceneName.split(' - ')[1]}</a>`;
                        navList.appendChild(sceneItem);
                    });
                }
            });
            
            // Set initial active state if no scene is currently selected
            if (!currentScene && Object.keys(play.acts).length > 0) {
                const firstAct = Object.keys(play.acts)[0];
                if (play.acts[firstAct] && play.acts[firstAct].length > 0) {
                    const firstScene = play.acts[firstAct][0];
                    updateActiveNavigation(firstScene);
                }
            }
        }

        // Load the first scene of a specific act
        function loadFirstSceneOfAct(actName) {
            if (!currentPlay || !plays[currentPlay] || !plays[currentPlay].acts[actName]) {
                console.log('Act not found:', actName, 'in play:', currentPlay);
                return;
            }
            
            const scenes = plays[currentPlay].acts[actName];
            if (scenes && scenes.length > 0) {
                const firstScene = scenes[0];
                loadScene(firstScene);
            }
        }

        // Load a specific scene
        function loadScene(sceneName) {
            if (!currentPlay || !plays[currentPlay] || !plays[currentPlay].scenes[sceneName]) {
                console.log('Scene not found:', sceneName, 'in play:', currentPlay);
                alert('Scene not found: ' + sceneName);
                return;
            }

            currentScene = sceneName;
            const sceneContent = plays[currentPlay].scenes[sceneName];
            
            console.log('Loading scene:', sceneName, 'with content length:', sceneContent.length);
            
            // Update active navigation
            updateActiveNavigation(sceneName);
            
            // Display scene content
            const playText = document.getElementById('playText');
            const formattedContent = formatSceneContent(sceneContent);
            playText.innerHTML = `
                <div class="scene-title">${sceneName}</div>
                <div class="scene-separator"></div>
                ${formattedContent}
            `;
            
            // Update meta line when scene changes
            updateMetaLine();
        }

        // Simple format scene content - display exactly as uploaded
        function formatSceneContent(sceneContent) {
            if (!sceneContent || sceneContent.length === 0) {
                return '<p><em>No content found for this scene.</em></p>';
            }
            
            let html = '';
            
            // Display each line exactly as it appears in the file, preserving whitespace
            sceneContent.forEach(line => {
                // Don't trim - preserve original spacing and empty lines
                if (line === '') {
                    // Empty line - preserve it
                    html += `<div class="play-line">&nbsp;</div>`;
                } else {
                    // Non-empty line - preserve original spacing
                    html += `<div class="play-line">${line}</div>`;
                }
            });
            
            return html;
        }
        

        
        // Check if a line is a speaker name
        function isSpeakerName(line) {
            // Must be all caps, reasonable length, and not a stage direction
            const isAllCaps = line.match(/^[A-Z\s]+$/) && 
                             line.length > 2 && 
                             line.length < 50 && 
                             !line.startsWith('[') && 
                             !line.endsWith(']') &&
                             !line.includes('ACT') &&
                             !line.includes('SCENE');
            
            if (!isAllCaps) return false;
            
            // If we have a current play, cross-reference with character list
            if (currentPlay && plays[currentPlay] && plays[currentPlay].characters) {
                return plays[currentPlay].characters.includes(line);
            }
            
            // Fallback to just checking if it looks like a speaker name
            return true;
        }
        
        // Check if a line is a stage direction
        function isStageDirection(line) {
            return line.startsWith('[') && line.endsWith(']');
        }

        // Analyze the text to identify speaker patterns
        function analyzeSpeakerPatterns(sceneContent) {
            const patterns = {
                allCaps: [],
                boldText: [],
                numberedSpeakers: [],
                titleSpeakers: [],
                potentialSpeakers: []
            };
            
            sceneContent.forEach((line, index) => {
                const trimmedLine = line.trim();
                if (trimmedLine === '') return;
                
                // Check for bold text patterns
                if (trimmedLine.startsWith('**') && trimmedLine.endsWith('**')) {
                    patterns.boldText.push({ line: trimmedLine, index });
                }
                
                // Check for all caps patterns
                if (trimmedLine.match(/^[A-Z\s]+$/) && trimmedLine.length > 2 && trimmedLine.length < 50) {
                    patterns.allCaps.push({ line: trimmedLine, index });
                }
                
                // Check for numbered speakers
                if (trimmedLine.match(/^(FIRST|SECOND|THIRD|FOURTH|FIFTH|SIXTH|SEVENTH|EIGHTH|NINTH|TENTH)\s+[A-Z\s]+$/)) {
                    patterns.numberedSpeakers.push({ line: trimmedLine, index });
                }
                
                // Check for title-based speakers
                const titleMatch = trimmedLine.match(/^[A-Z\s]+(KING|QUEEN|PRINCE|PRINCESS|DUKE|DUCHESS|LORD|LADY|SIR|MADAM|MISTRESS|CAPTAIN|GENTLEMAN|GENTLEWOMAN|SERVANT|MESSENGER|SOLDIER|GUARD|PRIEST|FRIAR|NURSE|ATTENDANT|OFFICER|CLOWN|FOOL|JESTER|HERALD|AMBASSADOR|SENATOR|COUNCILLOR|JUDGE|LAWYER|DOCTOR|APOTHECARY|MERCHANT|TRADER|ARTISAN|PEASANT|CITIZEN|COMMONER|VILLAGER|TOWNSMAN|COUNTRYMAN|SHEPHERD|HUNTER|FISHERMAN|FARMER|GARDENER|COOK|BUTLER|MAID|PAGE|BOY|GIRL|CHILD|MAN|WOMAN|PERSON|FRIEND|ENEMY|STRANGER|VISITOR|GUEST|HOST|HOSTESS|INNKEEPER|TAVERN|SHOPKEEPER|CRAFTSMAN|SCHOLAR|STUDENT|TEACHER|MASTER|SERVANT|SLAVE|PRISONER|EXILE|REFUGEE|WANDERER|TRAVELER|PILGRIM|HERMIT|WITCH|WIZARD|SORCERER|MAGICIAN|PROPHET|ORACLE|SEER|FORTUNE|TELLER|BEGGAR|THIEF|ROBBER|PIRATE|MURDERER|ASSASSIN|SPY|TRAITOR|REBEL|CONSPIRATOR|REVOLUTIONARY|PATRIOT|LOYALIST|ROYALIST|REPUBLICAN|DEMOCRAT|LIBERAL|CONSERVATIVE|RADICAL|MODERATE|EXTREMIST|FANATIC|ZEALOT|HERETIC|BLASPHEMER|SINNER|SAINT|MARTYR|HERO|VILLAIN|PROTAGONIST|ANTAGONIST|SUPPORTING|CHARACTER|EXTRA|WALK|ON|CROWD|CHORUS|NARRATOR|STORYTELLER|COMMENTATOR|ANNOUNCER|CALLER|BARKER|CUSTOMER|CLIENT|PATRON|REGULAR|FAMILIAR|UNKNOWN|MYSTERIOUS|HIDDEN|SECRET|PRIVATE|PUBLIC|OFFICIAL|UNOFFICIAL|FORMAL|INFORMAL|CASUAL|CEREMONIAL|RITUAL|TRADITIONAL|MODERN|CONTEMPORARY|ANCIENT|OLD|NEW|YOUNG|ELDER|SENIOR|JUNIOR|MAJOR|MINOR|PRIMARY|SECONDARY|TERTIARY|QUATERNARY|QUINARY|SENARY|SEPTENARY|OCTONARY|NONARY|DENARY)$/);
                if (titleMatch) {
                    patterns.titleSpeakers.push({ line: trimmedLine, index });
                }
                
                // Look for potential speakers based on context
                if (isPotentialSpeaker(trimmedLine, index, sceneContent)) {
                    patterns.potentialSpeakers.push({ line: trimmedLine, index });
                }
            });
            
            return patterns;
        }

        // Check if a line is a potential speaker based on context
        function isPotentialSpeaker(line, index, sceneContent) {
            // Skip if line is too short or too long
            if (line.length < 3 || line.length > 50) return false;
            
            // Skip if it's clearly not a speaker
            if (line.startsWith('[') || line.endsWith(']') || 
                line.includes('ACT') || line.includes('SCENE') ||
                line.includes('ENTER') || line.includes('EXIT') || line.includes('EXEUNT')) {
                return false;
            }
            
            // Simple check: if it's all caps and reasonable length, it might be a speaker
            if (line.match(/^[A-Z\s]+$/) && line.length > 2 && line.length < 50) {
                // Quick check for the next few lines to see if there's dialogue
                const nextLines = sceneContent.slice(index + 1, index + 3);
                for (let i = 0; i < nextLines.length; i++) {
                    const nextLine = nextLines[i].trim();
                    if (nextLine && nextLine.length > 10 && !nextLine.match(/^[A-Z\s]+$/)) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        // Check if a line represents a speaker using multiple detection methods
        function isSpeakerLine(line, patterns, index, sceneContent) {
            const trimmedLine = line.trim();
            
            // Check for bold text patterns
            if (trimmedLine.startsWith('**') && trimmedLine.endsWith('**')) {
                return true;
            }
            
            // Primary check: All caps speaker names (most common pattern)
            if (trimmedLine.match(/^[A-Z\s,]+$/) && trimmedLine.length > 2 && trimmedLine.length < 50) {
                // Avoid stage directions and scene markers
                const stageDirections = ['ACT', 'SCENE', 'ENTER', 'EXIT', 'EXEUNT', 'WITHIN', 'ABOVE', 'BELOW', 'CURTAIN'];
                const upperLine = trimmedLine.toUpperCase();
                
                if (stageDirections.some(word => upperLine.includes(word))) {
                    return false;
                }
                
                // Check if this line is followed by dialogue (not another speaker)
                const nextLines = sceneContent.slice(index + 1, index + 3);
                for (const nextLine of nextLines) {
                    const nextTrimmed = nextLine.trim();
                    if (nextTrimmed && nextTrimmed.length > 5) {
                        // If next line is also all caps, this might not be a speaker
                        if (nextTrimmed.match(/^[A-Z\s,]+$/)) {
                            return false;
                        }
                        // If next line looks like dialogue, this is likely a speaker
                        return true;
                    }
                }
            }
            
            // Check if this line matches any of our identified patterns
            const allPatterns = [
                ...patterns.boldText,
                ...patterns.allCaps,
                ...patterns.numberedSpeakers,
                ...patterns.titleSpeakers,
                ...patterns.potentialSpeakers
            ];
            
            // Check if this line is in our identified patterns
            for (const pattern of allPatterns) {
                if (pattern.line === trimmedLine && pattern.index === index) {
                    return true;
                }
            }
            
            return false;
        }





        // Extract speaker name from a line
        function extractSpeakerName(line) {
            // Remove bold markers if present
            if (line.startsWith('**') && line.endsWith('**')) {
                return line.slice(2, -2);
            }
            
            // Return the line as-is for other patterns
            return line;
        }

        // Update active navigation
        function updateActiveNavigation(itemName) {
            const navLinks = document.querySelectorAll('.navigation-list a');
            navLinks.forEach(link => {
                link.classList.remove('active');
            });
            
            // If it's a scene, highlight both the scene and its parent act
            if (itemName && itemName.includes(' - ')) {
                const actName = itemName.split(' - ')[0];
                
                navLinks.forEach(link => {
                    // Highlight the parent act
                    if (link.textContent === actName) {
                        link.classList.add('active');
                    }
                    
                    // Highlight the specific scene using data attribute
                    if (link.getAttribute('data-scene') === itemName) {
                        link.classList.add('active');
                    }
                });
            } else if (itemName === 'dramatis') {
                // Highlight Dramatis Personae
                navLinks.forEach(link => {
                    if (link.textContent === 'Dramatis Personae') {
                        link.classList.add('active');
                    }
                });
            } else if (itemName) {
                // Highlight just the act
                navLinks.forEach(link => {
                    if (link.textContent === itemName) {
                        link.classList.add('active');
                    }
                });
            }
        }

        // Show Dramatis Personae
        function showDramatisPersonae() {
            if (!currentPlay || !plays[currentPlay]) return;
            
            const characters = plays[currentPlay].characters;
            const playText = document.getElementById('playText');
            
            // Update active navigation
            updateActiveNavigation('dramatis');
            
            playText.innerHTML = `
                <div class="scene-title">Dramatis Personae</div>
                <div class="scene-separator"></div>
                <div class="analysis-content">
                    ${characters.length > 0 ? 
                        characters.map(char => `<p><strong>${char}</strong></p>`).join('') :
                        '<p><em>No character list found in this play.</em></p>'
                    }
                </div>
            `;
        }

        // Show Act overview
        function showAct(actName) {
            if (!currentPlay || !plays[currentPlay] || !plays[currentPlay].acts[actName]) return;
            
            const scenes = plays[currentPlay].acts[actName];
            const playText = document.getElementById('playText');
            
            // Update active navigation
            updateActiveNavigation(actName);
            
            playText.innerHTML = `
                <div class="scene-title">${actName}</div>
                <div class="scene-separator"></div>
                <div class="analysis-content">
                    <p>This act contains ${scenes.length} scene${scenes.length !== 1 ? 's' : ''}:</p>
                    ${scenes.map(scene => `<p><a href="#" onclick="loadScene('${scene}')">${scene.split(' - ')[1]}</a></p>`).join('')}
                </div>
            `;
        }

        // Change play
        function changePlay() {
            const selector = document.getElementById('playSelector');
            const selectedPlay = selector.value;
            if (selectedPlay) {
                loadPlay(selectedPlay);
            }
        }

        // Function to update the meta line with current selection info
        function updateMetaLine() {
            const analysisPanel = document.getElementById('analysisPanel');
            if (!analysisPanel) {
                console.log('No analysis panel found');
                return;
            }
            
            const playName = currentPlay && plays[currentPlay] ? plays[currentPlay].name : 'Unknown Play';
            const wordCount = selectedText ? countWords(selectedText) : 0;
            
            console.log('updateMetaLine - playName:', playName, 'selectedText:', selectedText, 'wordCount:', wordCount);
            
            let metaText = '';
            if (selectedText && wordCount > 0) {
                const wordText = wordCount === 1 ? 'word' : 'words';
                metaText = `<em>${playName}</em> · ${currentScene} · ${wordCount} ${wordText} highlighted`;
            } else {
                metaText = `<em>${playName}</em> · ${currentScene} · No text highlighted`;
            }
            
            console.log('Generated metaText:', metaText);
            
            // Update the meta line if it exists
            const metaElement = analysisPanel.querySelector('.meta');
            if (metaElement) {
                metaElement.innerHTML = metaText;
                console.log('Meta line updated successfully');
            } else {
                console.log('No meta element found in analysis panel');
            }
        }

        // Text selection functionality - using mouseup for immediate response
        document.addEventListener('mouseup', function() {
            const selection = window.getSelection();
            const newSelectedText = selection.toString().trim();
            
            console.log('Mouseup event - selected text:', newSelectedText, 'length:', newSelectedText.length);
            
            // Check if selection is within the reading pane
            const readerElement = document.querySelector('.reader');
            if (!readerElement) {
                console.log('No reader element found');
                selectedText = '';
                clearAllHighlights();
                updateMetaLine();
                return;
            }
            
            // Check if the selection is actually within the reading pane
            if (newSelectedText) {
                const selectionRange = selection.getRangeAt(0);
                if (!readerElement.contains(selectionRange.commonAncestorContainer)) {
                    console.log('Selection outside reader element');
                    selectedText = '';
                    clearAllHighlights();
                    updateMetaLine();
                    return;
                }
            }
            
            // Update selected text
            selectedText = newSelectedText;
            console.log('Updated selectedText to:', selectedText, 'length:', selectedText.length);
            
            if (selectedText) {
                // Clear any existing highlights first
                clearAllHighlights();
                
                // Use a non-destructive highlighting method that preserves original formatting
                try {
                    const range = selection.getRangeAt(0);
                    const span = document.createElement('span');
                    span.className = 'highlight';
                    
                    // Create a clone of the range contents to avoid modifying the original DOM
                    const clonedContents = range.cloneContents();
                    span.appendChild(clonedContents);
                    
                    // Replace the range contents with our highlighted span
                    range.deleteContents();
                    range.insertNode(span);
                    
                    console.log('Non-destructive highlighting successful');
                } catch (highlightError) {
                    console.warn('Highlighting failed, but keeping selection:', highlightError);
                    // Even if highlighting fails, we still have the selected text
                }
            }
            
            // Always update meta line after selection changes
            console.log('Calling updateMetaLine with selectedText:', selectedText);
            updateMetaLine();
        });
        
        // Clear highlighting when clicking in the reading pane (without selecting text)
        document.addEventListener('click', function(event) {
            const readerElement = document.querySelector('.reader');
            if (!readerElement) return;
            
            // Check if click is within the reading pane
            if (readerElement.contains(event.target)) {
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                
                // Only clear highlighting if no text is currently selected
                if (!selectedText && document.querySelectorAll('.highlight').length > 0) {
                    console.log('Clearing highlights due to click in reading pane');
                    clearAllHighlights();
                    updateMetaLine();
                }
            }
        });

        // Function to clear all existing highlights
        function clearAllHighlights() {
            const highlights = document.querySelectorAll('.highlight');
            highlights.forEach(highlight => {
                const parent = highlight.parentNode;
                
                // Move all child nodes out of the highlight span and into the parent
                while (highlight.firstChild) {
                    parent.insertBefore(highlight.firstChild, highlight);
                }
                
                // Remove the empty highlight span
                parent.removeChild(highlight);
                
                // Normalize to merge adjacent text nodes
                parent.normalize();
            });
        }

        // Contextual toolbar event listeners




        function explainHighlighted() {
            if (!selectedText) {
                alert('Please highlight some text first, then click "Explain Highlighted Text".');
                return;
            }
            
            // Call the serverless function to analyze the highlighted text
            analyzeHighlightedText(selectedText);
        }

        // Helper function to count words accurately
        function countWords(text) {
            if (!text || typeof text !== 'string') return 0;
            // Remove extra whitespace and split by whitespace, filter out empty strings
            return text.trim().split(/\s+/).filter(word => word.length > 0).length;
        }

        async function analyzeHighlightedText(text) {
            // Check cache first
            const playName = currentPlay && plays[currentPlay] ? plays[currentPlay].name : 'Unknown Play';
            const cachedContent = getCachedAnalysis(text, currentAnalysisMode, playName, currentScene);
            
            if (cachedContent) {
                console.log('Using cached analysis');
                updateAnalysis(cachedContent, text);
                return;
            }
            
            // Show processing message with proper meta information
            const analysisPanel = document.getElementById('analysisPanel');
            const wordCount = countWords(text);
            const wordText = wordCount === 1 ? 'word' : 'words';
            const playInfo = `${playName}, ${currentScene}, ${wordCount} ${wordText} highlighted`;
            
            // Get the correct title based on current mode
            let analysisTitle = 'Basic Analysis';
            switch(currentAnalysisMode) {
                case 'basic':
                    analysisTitle = 'Basic Analysis';
                    break;
                case 'intermediate':
                    analysisTitle = 'Intermediate Analysis';
                    break;
                case 'expert':
                    analysisTitle = 'Expert Analysis';
                    break;
                case 'fullfathomfive':
                    analysisTitle = 'Full Fathom Five Analysis';
                    break;
            }
            
            analysisPanel.innerHTML = `
                <!-- Analysis Mode Selector -->
                <div class="segment">
                    <button onclick="setAnalysisMode('basic')" aria-pressed="${currentAnalysisMode === 'basic' ? 'true' : 'false'}">Basic</button>
                    <button onclick="setAnalysisMode('intermediate')" aria-pressed="${currentAnalysisMode === 'intermediate' ? 'true' : 'false'}">Intermediate</button>
                    <button onclick="setAnalysisMode('expert')" aria-pressed="${currentAnalysisMode === 'expert' ? 'true' : 'false'}">Expert</button>
                    <button onclick="setAnalysisMode('fullfathomfive')" aria-pressed="${currentAnalysisMode === 'fullfathomfive' ? 'true' : 'false'}">Full Fathom Five</button>
                </div>

                <!-- AI Analysis Content -->
                <div class="analysis-header">
                    <div class="analysis-title">${analysisTitle}</div>
                    <button class="copy-btn" onclick="copyAnalysis()">Copy</button>
                </div>
                <div class="analysis">
                    <div class="meta" style="font-weight: bold;"><em>${playName}</em> · ${currentScene} · ${wordCount} ${wordCount === 1 ? 'word' : 'words'} highlighted</div>
                    <div class="analysis-content">
                        <p style="font-family: var(--ui); font-style: italic;">Processing.</p>
                    </div>
                </div>
            `;
            
            try {
                console.log('Analyzing text:', text.substring(0, 100) + '...');
                
                // Try the redirect path first
                let response = await fetch('/api/shakespeare', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: text,
                        level: currentAnalysisMode,
                        model: 'gpt-4o-mini'
                    })
                });
                
                // If that fails, try the direct function path
                if (!response.ok) {
                    console.log('Redirect failed, trying direct function path...');
                    response = await fetch('/.netlify/functions/shakespeare', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            text: text,
                            level: currentAnalysisMode,
                            model: 'gpt-4o-mini'
                        })
                    });
                }
                
                console.log('Response status:', response.status);
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('Server error:', errorData);
                    
                    if (response.status === 500 && errorData.error && errorData.error.includes('API key')) {
                        alert('OpenAI API key not configured. Please check your Netlify environment variables.');
                    } else {
                        throw new Error(`HTTP ${response.status}: ${errorData.error || 'Unknown error'}`);
                    }
                    return;
                }
                
                const data = await response.json();
                console.log('Response data:', data);
                
                if (data.choices && data.choices[0] && data.choices[0].message) {
                    const content = data.choices[0].message.content;
                    
                    // Cache the analysis
                    cacheAnalysis(text, currentAnalysisMode, playName, currentScene, content);
                    
                    updateAnalysis(content, text);
                } else if (data.error) {
                    throw new Error(data.error);
                } else {
                    throw new Error('Invalid response format from server');
                }
                
            } catch (error) {
                console.error('Error analyzing text:', error);
                
                // More specific error messages
                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    alert('Network error. Please check your internet connection and try again.');
                } else if (error.message.includes('API key')) {
                    alert('OpenAI API key not configured. Please check your Netlify environment variables.');
                } else {
                    alert(`Error analyzing text: ${error.message}. Please try again.`);
                }
            }
        }

        function updateAnalysis(content, text) {
            const analysisPanel = document.getElementById('analysisPanel');
            const wordCount = countWords(text);
            const playName = currentPlay && plays[currentPlay] ? plays[currentPlay].name : 'Unknown Play';
            const playInfo = `<em>${playName}</em> · ${currentScene}`;
            
            // Format the content with proper sections
            const formattedContent = formatAnalysisContent(content);
            
            // Get the correct title based on current mode
            let analysisTitle = 'Basic Analysis';
            switch(currentAnalysisMode) {
                case 'basic':
                    analysisTitle = 'Basic Analysis';
                    break;
                case 'intermediate':
                    analysisTitle = 'Intermediate Analysis';
                    break;
                case 'expert':
                    analysisTitle = 'Expert Analysis';
                    break;
                case 'fullfathomfive':
                    analysisTitle = 'Full Fathom Five Analysis';
                    break;
            }
            
            analysisPanel.innerHTML = `
                <!-- Analysis Mode Selector -->
                <div class="segment">
                    <button onclick="setAnalysisMode('basic')" aria-pressed="${currentAnalysisMode === 'basic' ? 'true' : 'false'}">Basic</button>
                    <button onclick="setAnalysisMode('intermediate')" aria-pressed="${currentAnalysisMode === 'intermediate' ? 'true' : 'false'}">Intermediate</button>
                    <button onclick="setAnalysisMode('expert')" aria-pressed="${currentAnalysisMode === 'expert' ? 'true' : 'false'}">Expert</button>
                    <button onclick="setAnalysisMode('fullfathomfive')" aria-pressed="${currentAnalysisMode === 'fullfathomfive' ? 'true' : 'false'}">Full Fathom Five</button>
                </div>

                <!-- AI Analysis Content -->
                <div class="analysis">
                    <button class="copy-chip" onclick="copyAnalysis()">Copy</button>
                    <div class="meta">${playInfo} — ${wordCount} ${wordCount === 1 ? 'word' : 'words'} selected</div>
                    <div class="analysis-content">
                        ${formattedContent}
                    </div>
                    
                    <!-- Media Section -->
                    <h3>Media</h3>
                    <div class="media-actions">
                        <button class="link-btn youtube" onclick="searchYouTube('scene')">Search YouTube for this scene</button>
                    </div>

                    <!-- Research Section -->
                    <h3>Research</h3>
                    <div class="research-actions">
                        <button class="link-btn jstor" onclick="searchJSTOR('exact')">Search JSTOR for exact quotation</button>
                        <button class="link-btn jstor" onclick="searchJSTOR('passage')">Search JSTOR for this passage/scene</button>
                        <button class="link-btn scholar" onclick="searchGoogleScholar()">Google Scholar</button>
                        <button class="link-btn ise" onclick="openInternetShakespeare()">Internet Shakespeare Editions</button>
                    </div>

                    <!-- Follow-up Section -->
                    <h3>Ask a follow-up question</h3>
                    <div class="follow-up-input">
                        <input type="text" placeholder="Ask a follow-up question..." id="followUpQuestion">
                        <button class="ask-btn" onclick="askFollowUp()">Ask</button>
                    </div>
                </div>
            `;
        }

        function formatAnalysisContent(content) {
            // Debug: Log the raw content to see what the AI is returning
            console.log('Raw AI content:', content);
            
            // Parse the content into structured sections
            const sections = content.split(/\n\n+/);
            console.log('Parsed sections:', sections);
            let formattedContent = '';
            
            // Define the uniform section order for all analysis levels
            const standardSections = [
                'Plain-Language Paraphrase',
                'Synopsis',
                'Textual Variants',
                'Key Words & Glosses',
                'Historical Context',
                'Literary Analysis',
                'Critical Reception',
                'Performance History',
                'Bibliography',
                'Notes',
                'Pointers for Further Reading'
            ];
            
            // Extract and organize content by section type
            const sectionContent = {};
            console.log('Section content mapping:');
            
            sections.forEach((section, index) => {
                const trimmedSection = section.trim();
                if (!trimmedSection) return;
                
                // Extract section title and content
                let sectionTitle = '';
                let sectionText = '';
                
                // Handle numbered sections (Intermediate/Expert)
                const numberedMatch = trimmedSection.match(/^(\d+)\.\s*(\d+\.)?\s*(.+?)(?:\n|$)/);
                if (numberedMatch) {
                    sectionTitle = numberedMatch[3].trim();
                    sectionText = trimmedSection.split('\n').slice(1).join('\n').trim();
                } else {
                    // Handle bold section headers (new format: **Section Name:**)
                    const boldMatch = trimmedSection.match(/^\*\*(.+?)\*\*:\s*(.+)/s);
                    if (boldMatch) {
                        sectionTitle = boldMatch[1].trim();
                        sectionText = boldMatch[2].trim();
                    } else {
                        // Handle dash-separated sections (Basic/FFF)
                        const dashMatch = trimmedSection.match(/^(.+?)\s*—\s*(.+)/s);
                        if (dashMatch) {
                            sectionTitle = dashMatch[1].trim();
                            sectionText = dashMatch[2].trim();
                        } else {
                            // Handle plain text
                            sectionText = trimmedSection;
                        }
                    }
                }
                
                // Clean up section title
                sectionTitle = sectionTitle.replace(/\*\*(.*?)\*\*/g, '$1').trim();
                
                                 // Map to standard section names
                 let mappedTitle = '';
                 for (const standardSection of standardSections) {
                     if (sectionTitle.toLowerCase().includes(standardSection.toLowerCase()) ||
                         standardSection.toLowerCase().includes(sectionTitle.toLowerCase())) {
                         mappedTitle = standardSection;
                         break;
                     }
                 }
                 
                 // Handle specific section mappings
                 if (sectionTitle.toLowerCase().includes('textual check') || 
                     sectionTitle.toLowerCase().includes('textual variant') ||
                     sectionTitle.toLowerCase().includes('apparatus criticus')) {
                     mappedTitle = 'Textual Variants';
                 }
                 
                 if (sectionTitle.toLowerCase().includes('key words') && 
                     !sectionTitle.toLowerCase().includes('glosses')) {
                     mappedTitle = 'Key Words & Glosses';
                 }
                
                if (mappedTitle) {
                    sectionContent[mappedTitle] = sectionText;
                    console.log(`Mapped "${sectionTitle}" to "${mappedTitle}"`);
                } else {
                    // Handle special cases
                    if (sectionTitle.toLowerCase().includes('integrity check')) {
                        // Skip integrity check sections
                        console.log(`Skipping integrity check: "${sectionTitle}"`);
                        return;
                    } else if (sectionTitle.toLowerCase().includes('notes')) {
                        sectionContent['Notes'] = sectionText;
                        console.log(`Added notes section`);
                    } else {
                        // Default case
                        sectionContent[sectionTitle] = sectionText;
                        console.log(`Added unmapped section: "${sectionTitle}"`);
                    }
                }
            });
            
                         // Store notes for later integration
            let notesContent = '';
            
            // Build formatted content in standard order
            standardSections.forEach(sectionName => {
                if (sectionContent[sectionName]) {
                    const content = sectionContent[sectionName];
                    
                    if (sectionName === 'Key Words & Glosses') {
                        formattedContent += `<div class="section">`;
                        formattedContent += `<h3><strong>${sectionName}:</strong></h3>`;
                        formattedContent += formatKeyWords(content);
                        formattedContent += `</div>`;
                    } else if (sectionName === 'Pointers for Further Reading') {
                        formattedContent += `<div class="section">`;
                        formattedContent += `<h3><strong>${sectionName}:</strong></h3>`;
                        formattedContent += formatFurtherReading(content);
                        formattedContent += `</div>`;
                    } else if (sectionName === 'Textual Variants') {
                        formattedContent += `<div class="section">`;
                        formattedContent += `<h3><strong>${sectionName}:</strong></h3>`;
                        formattedContent += formatTextualVariants(content);
                        formattedContent += `</div>`;
                    } else if (sectionName === 'Notes') {
                        // Store notes for later integration into relevant sections
                        notesContent = content;
                    } else {
                        formattedContent += `<div class="section">`;
                        formattedContent += `<h3><strong>${sectionName}:</strong></h3>`;
                        const processedContent = processContentForFormatting(content);
                        formattedContent += `<p>${processedContent}</p>`;
                        formattedContent += `</div>`;
                    }
                }
            });
             
             // Add any remaining sections that weren't in the standard order
             Object.keys(sectionContent).forEach(sectionName => {
                 if (!standardSections.includes(sectionName) && sectionName !== 'Notes') {
                     const content = sectionContent[sectionName];
                     formattedContent += `<div class="section">`;
                     formattedContent += `<h3><strong>${sectionName}:</strong></h3>`;
                     const processedContent = processContentForFormatting(content);
                     formattedContent += `<p>${processedContent}</p>`;
                     formattedContent += `</div>`;
                 }
             });
             
             // Integrate notes into relevant sections if they exist
             if (notesContent) {
                 formattedContent = integrateNotesIntoSections(formattedContent, notesContent);
             }
            
            console.log('Final formatted content length:', formattedContent.length);
            return formattedContent;
        }
        
        function formatKeyWords(content) {
            const lines = content.split('\n');
            let dlContent = '';
            
            lines.forEach(line => {
                if (line.includes('—')) {
                    const [word, def] = line.split('—', 2);
                    if (word && def) {
                        const cleanWord = word.replace(/^[-*\s]+/, '').trim();
                        const cleanDef = def.replace(/^[-*\s]+/, '').trim();
                        dlContent += `<dt><strong>${cleanWord}</strong></dt><dd> — ${cleanDef}</dd>`;
                    }
                }
            });
            
            return dlContent ? `<dl>${dlContent}</dl>` : `<p>${processContentForFormatting(content)}</p>`;
        }
        
                 function formatTextualVariants(content) {
             const lines = content.split('\n');
             let formattedContent = '';
             let hasTable = false;
             
             // Check if content contains a variant table
             const tableMatch = content.match(/\|.*First.*Quarto.*\|.*Second.*Quarto.*\|.*First.*Folio.*\|/);
             
             if (tableMatch) {
                 // Extract and format the variant table
                 const tableLines = lines.filter(line => line.includes('|'));
                 if (tableLines.length > 0) {
                     formattedContent += `<table class="variant-table">`;
                     formattedContent += `<thead><tr><th>Edition</th><th>Reading</th><th>Effect</th></tr></thead>`;
                     formattedContent += `<tbody>`;
                     
                     tableLines.forEach(line => {
                         if (line.includes('|')) {
                             const cells = line.split('|').map(cell => cell.trim()).filter(cell => cell);
                             if (cells.length >= 3) {
                                 formattedContent += `<tr>`;
                                 formattedContent += `<td><strong>${cells[0]}</strong></td>`;
                                 formattedContent += `<td>"${cells[1]}"</td>`;
                                 formattedContent += `<td>${cells[2]}</td>`;
                                 formattedContent += `</tr>`;
                             }
                         }
                     });
                     
                     formattedContent += `</tbody></table>`;
                     hasTable = true;
                 }
             }
             
             // Add any descriptive text before or after the table
             const descriptiveText = lines.filter(line => !line.includes('|') && line.trim()).join(' ');
             if (descriptiveText) {
                 const processedText = processContentForFormatting(descriptiveText);
                 if (hasTable) {
                     formattedContent = `<p>${processedText}</p>` + formattedContent;
                 } else {
                     formattedContent = `<p>${processedText}</p>`;
                 }
             }
             
             // If no table and content mentions "no material variance" or similar, use the new language
             if (!hasTable) {
                 const noVariancePhrases = [
                     'no material variance',
                     'no variance',
                     'identical',
                     'matches folger'
                 ];
                 
                 const hasNoVariance = noVariancePhrases.some(phrase => 
                     content.toLowerCase().includes(phrase.toLowerCase())
                 );
                 
                 if (hasNoVariance) {
                     return `<p>Early editions are identical to Folger.</p>`;
                 }
             }
             
             return formattedContent || `<p>${processContentForFormatting(content)}</p>`;
         }
         
         function formatFurtherReading(content) {
             const lines = content.split('\n');
             let formattedList = '';
             
             lines.forEach(line => {
                 if (line.includes('—')) {
                     const [source, description] = line.split('—', 2);
                     if (source && description) {
                         const cleanSource = source.replace(/^[-*\s]+/, '').trim();
                         const cleanDesc = description.replace(/^[-*\s]+/, '').trim();
                         formattedList += `<p><strong>${cleanSource}</strong>: ${cleanDesc}</p>`;
                     }
                 } else if (line.trim()) {
                     const cleanLine = line.replace(/^[-*\s]+/, '').trim();
                     if (cleanLine) {
                         formattedList += `<p>${cleanLine}</p>`;
                     }
                 }
             });
             
             return formattedList || `<p>${processContentForFormatting(content)}</p>`;
         }
        
                 function integrateNotesIntoSections(formattedContent, notesContent) {
             // Parse notes into individual citations
             const notes = notesContent.split(/\n+/).filter(note => note.trim());
             
             // Create a mapping of notes to relevant sections
             const sectionNotes = {
                 'Key Words & Glosses': [],
                 'Historical Context': [],
                 'Literary Analysis': [],
                 'Critical Reception': [],
                 'Textual Variants': [],
                 'Performance History': []
             };
             
             // Distribute notes to relevant sections based on content
             notes.forEach(note => {
                 const lowerNote = note.toLowerCase();
                 
                 if (lowerNote.includes('oed') || lowerNote.includes('dictionary') || lowerNote.includes('gloss')) {
                     sectionNotes['Key Words & Glosses'].push(note);
                 } else if (lowerNote.includes('history') || lowerNote.includes('period') || lowerNote.includes('context')) {
                     sectionNotes['Historical Context'].push(note);
                 } else if (lowerNote.includes('critic') || lowerNote.includes('scholar') || lowerNote.includes('interpretation')) {
                     sectionNotes['Critical Reception'].push(note);
                 } else if (lowerNote.includes('performance') || lowerNote.includes('stage') || lowerNote.includes('production')) {
                     sectionNotes['Performance History'].push(note);
                 } else if (lowerNote.includes('variant') || lowerNote.includes('edition') || lowerNote.includes('folio')) {
                     sectionNotes['Textual Variants'].push(note);
                 } else {
                     // Default to Literary Analysis for general notes
                     sectionNotes['Literary Analysis'].push(note);
                 }
             });
             
             // Insert notes into the appropriate sections
             Object.keys(sectionNotes).forEach(sectionName => {
                 if (sectionNotes[sectionName].length > 0) {
                     const sectionRegex = new RegExp(`<h3><strong>${sectionName}:</strong></h3>`, 'g');
                     const notesHtml = sectionNotes[sectionName].map(note => 
                         `<p>${processContentForFormatting(note)}</p>`
                     ).join('');
                     
                     formattedContent = formattedContent.replace(
                         sectionRegex,
                         `$&${notesHtml}`
                     );
                 }
             });
             
             return formattedContent;
         }
         
         function processContentForFormatting(content) {
            if (!content) return '';
            
            let processed = content;
            
            // Convert asterisks to bold tags
            processed = processed.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // Convert single asterisks to italics (for emphasis)
            processed = processed.replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // Convert shorthand to proper academic language
            processed = processed.replace(/\bvs\.\b/gi, 'versus');
            processed = processed.replace(/\bvs\b/gi, 'versus');
            processed = processed.replace(/\b&/g, 'and');
            processed = processed.replace(/\bw\/\b/gi, 'with');
            processed = processed.replace(/\bw\/o\b/gi, 'without');
            processed = processed.replace(/\betc\./gi, 'et cetera');
            processed = processed.replace(/\bi\.e\./gi, 'that is');
            processed = processed.replace(/\be\.g\./gi, 'for example');
            processed = processed.replace(/\bc\./gi, 'circa');
            processed = processed.replace(/\bca\./gi, 'circa');
            
            // More aggressive dash removal and sentence formatting
            processed = processed.replace(/^—\s*/gm, ''); // Remove leading dashes
            processed = processed.replace(/\n—\s*/g, '\n'); // Remove line-starting dashes
            processed = processed.replace(/^\s*—\s*/gm, ''); // Remove any leading dashes with spaces
            processed = processed.replace(/\s*—\s*/g, ' '); // Remove any remaining dashes with spaces
            
            // Fix fragmented sentences by joining lines that don't end with punctuation
            const lines = processed.split('\n');
            const joinedLines = [];
            let currentSentence = '';
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) {
                    if (currentSentence) {
                        joinedLines.push(currentSentence);
                        currentSentence = '';
                    }
                    continue;
                }
                
                // If line ends with punctuation, it's a complete sentence
                if (line.match(/[.!?]$/)) {
                    currentSentence += (currentSentence ? ' ' : '') + line;
                    joinedLines.push(currentSentence);
                    currentSentence = '';
                } else {
                    // If line doesn't end with punctuation, it's likely a fragment
                    currentSentence += (currentSentence ? ' ' : '') + line;
                }
            }
            
            // Add any remaining sentence
            if (currentSentence) {
                joinedLines.push(currentSentence);
            }
            
            processed = joinedLines.join('\n\n');
            
            // Ensure proper sentence structure
            processed = processed.replace(/([.!?])\s*([A-Z])/g, '$1 $2'); // Fix spacing after punctuation
            
            // Convert book titles to italics (more comprehensive)
            processed = processed.replace(/\*([^*]+)\*/g, '<em>$1</em>'); // Convert remaining asterisk-wrapped text to italics
            processed = processed.replace(/"([^"]*)"\s*\(([^)]*)\)/g, '<em>$1</em> ($2)');
            processed = processed.replace(/\b([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\s*\(([^)]*)\)/g, '<em>$1</em> ($2)');
            
            // Convert author names to proper format
            processed = processed.replace(/([A-Z][a-z]+),\s*([A-Z][a-z]+)/g, '$2 $1');
            
            // Fix common formatting issues
            processed = processed.replace(/\s+/g, ' '); // Normalize multiple spaces
            processed = processed.replace(/\n\s*\n/g, '\n\n'); // Normalize paragraph breaks
            
            return processed;
        }

        // Analysis mode state
        let currentAnalysisMode = 'basic';

        function setAnalysisMode(mode) {
            currentAnalysisMode = mode;
            
            // Update button states
            const buttons = document.querySelectorAll('.segment button');
            buttons.forEach(btn => {
                btn.setAttribute('aria-pressed', 'false');
            });
            
            // Find and activate the correct button
            const activeButton = document.querySelector(`.segment button[onclick*="${mode}"]`);
            if (activeButton) {
                activeButton.setAttribute('aria-pressed', 'true');
            }
            
            // Update the analysis title based on mode
            const analysisTitle = document.querySelector('.analysis-title');
            if (analysisTitle) {
                switch(mode) {
                    case 'basic':
                        analysisTitle.textContent = 'Basic Analysis';
                        break;
                    case 'intermediate':
                        analysisTitle.textContent = 'Intermediate Analysis';
                        break;
                    case 'expert':
                        analysisTitle.textContent = 'Expert Analysis';
                        break;
                    case 'fullfathomfive':
                        analysisTitle.textContent = 'Full Fathom Five Analysis';
                        break;
                }
            }
            
            // Don't automatically re-analyze - user must click "Explain Highlighted Text" button
        }

        function copyAnalysis() {
            const analysisContent = document.querySelector('.analysis-content');
            if (analysisContent) {
                const textToCopy = analysisContent.innerText;
                navigator.clipboard.writeText(textToCopy).then(() => {
                    // Show a brief success message
                    const copyBtn = document.querySelector('.copy-btn');
                    if (copyBtn) {
                        const originalText = copyBtn.textContent;
                        copyBtn.textContent = 'Copied!';
                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                        }, 1000);
                    }
                }).catch(err => {
                    console.error('Failed to copy text: ', err);
                    alert('Failed to copy analysis to clipboard');
                });
            }
        }

        function askFollowUp() {
            const question = document.getElementById('followUpQuestion').value.trim();
            if (!question) {
                alert('Please enter a question.');
                return;
            }
            
            // Here you would implement follow-up question functionality
            alert('Follow-up question feature coming soon!');
        }

        // Media and Research Functions
        function searchYouTube(type) {
            const playName = currentPlay && plays[currentPlay] ? plays[currentPlay].name : 'Shakespeare';
            const sceneName = currentScene || 'scene';
            const searchQuery = `${playName} ${sceneName} performance`;
            
            const url = `https://www.youtube.com/results?search_query=${encodeURIComponent(searchQuery)}`;
            window.open(url, '_blank');
        }

        function searchJSTOR(type) {
            if (!selectedText) {
                alert('Please select some text first to search JSTOR.');
                return;
            }
            
            let searchQuery = '';
            if (type === 'exact') {
                searchQuery = `"${selectedText}"`;
            } else {
                const playName = currentPlay && plays[currentPlay] ? plays[currentPlay].name : 'Shakespeare';
                searchQuery = `${playName} ${currentScene || 'scene'}`;
            }
            
            const url = `https://www.jstor.org/action/doBasicSearch?Query=${encodeURIComponent(searchQuery)}`;
            window.open(url, '_blank');
        }

        function searchGoogleScholar() {
            const playName = currentPlay && plays[currentPlay] ? plays[currentPlay].name : 'Shakespeare';
            const sceneName = currentScene || 'scene';
            
            // Extract Act information from the scene name
            let actInfo = '';
            if (currentScene && currentScene.includes(' - ')) {
                const actPart = currentScene.split(' - ')[0];
                if (actPart && actPart.includes('ACT')) {
                    actInfo = actPart;
                }
            }
            
            // Build search query with Act information
            let searchQuery = '';
            if (actInfo) {
                searchQuery = `${playName} ${actInfo} Shakespeare`;
            } else {
                searchQuery = `${playName} ${sceneName} Shakespeare`;
            }
            
            const url = `https://scholar.google.com/scholar?q=${encodeURIComponent(searchQuery)}`;
            window.open(url, '_blank');
        }



        function openInternetShakespeare() {
            const playName = currentPlay && plays[currentPlay] ? plays[currentPlay].name.toLowerCase().replace(/\s+/g, '-') : 'shakespeare';
            const url = `https://internetshakespeare.uvic.ca/Library/plays/${playName}/`;
            window.open(url, '_blank');
        }

        // Cache management functions
        function generateCacheKey(text, level, playName, sceneName) {
            // Create a unique key based on text content, analysis level, and context
            const textHash = btoa(text).slice(0, 20); // Simple hash of text
            return `analysis_${CACHE_VERSION}_${level}_${textHash}_${playName}_${sceneName}`;
        }
        
        function getCachedAnalysis(text, level, playName, sceneName) {
            try {
                const cacheKey = generateCacheKey(text, level, playName, sceneName);
                const cached = localStorage.getItem(cacheKey);
                
                if (!cached) return null;
                
                const analysis = JSON.parse(cached);
                const now = new Date().getTime();
                
                // Check if cache has expired
                if (analysis.timestamp && (now - analysis.timestamp) > (CACHE_EXPIRY_DAYS * 24 * 60 * 60 * 1000)) {
                    localStorage.removeItem(cacheKey);
                    return null;
                }
                
                console.log('Cache hit for:', text.substring(0, 50) + '...');
                return analysis.content;
                
            } catch (error) {
                console.warn('Error reading from cache:', error);
                return null;
            }
        }
        
        function cacheAnalysis(text, level, playName, sceneName, content) {
            try {
                const cacheKey = generateCacheKey(text, level, playName, sceneName);
                const analysis = {
                    content: content,
                    timestamp: new Date().getTime(),
                    version: CACHE_VERSION,
                    text: text.substring(0, 100), // Store first 100 chars for debugging
                    level: level,
                    playName: playName,
                    sceneName: sceneName
                };
                
                localStorage.setItem(cacheKey, JSON.stringify(analysis));
                
                // Manage cache size - remove oldest entries if we exceed MAX_CACHE_SIZE
                manageCacheSize();
                
                console.log('Cached analysis for:', text.substring(0, 50) + '...');
                
            } catch (error) {
                console.warn('Error caching analysis:', error);
                // If localStorage is full, clear some old entries and try again
                if (error.name === 'QuotaExceededError') {
                    clearOldCacheEntries();
                    try {
                        localStorage.setItem(cacheKey, JSON.stringify(analysis));
                    } catch (retryError) {
                        console.warn('Failed to cache after cleanup:', retryError);
                    }
                }
            }
        }
        
        function manageCacheSize() {
            try {
                const cacheKeys = Object.keys(localStorage).filter(key => key.startsWith('analysis_'));
                
                if (cacheKeys.length <= MAX_CACHE_SIZE) return;
                
                // Sort by timestamp (oldest first) and remove excess
                const cacheEntries = cacheKeys.map(key => {
                    try {
                        const cached = JSON.parse(localStorage.getItem(key));
                        return { key, timestamp: cached.timestamp || 0 };
                    } catch {
                        return { key, timestamp: 0 };
                    }
                }).sort((a, b) => a.timestamp - b.timestamp);
                
                // Remove oldest entries
                const toRemove = cacheEntries.slice(0, cacheKeys.length - MAX_CACHE_SIZE);
                toRemove.forEach(entry => {
                    localStorage.removeItem(entry.key);
                });
                
                console.log(`Cleared ${toRemove.length} old cache entries`);
                
            } catch (error) {
                console.warn('Error managing cache size:', error);
            }
        }
        
        function clearOldCacheEntries() {
            try {
                const now = new Date().getTime();
                const cacheKeys = Object.keys(localStorage).filter(key => key.startsWith('analysis_'));
                
                cacheKeys.forEach(key => {
                    try {
                        const cached = JSON.parse(localStorage.getItem(key));
                        if (cached.timestamp && (now - cached.timestamp) > (CACHE_EXPIRY_DAYS * 24 * 60 * 60 * 1000)) {
                            localStorage.removeItem(key);
                        }
                    } catch {
                        localStorage.removeItem(key);
                    }
                });
                
                console.log('Cleared expired cache entries');
                
            } catch (error) {
                console.warn('Error clearing old cache entries:', error);
            }
        }
        
        function clearAllCache() {
            try {
                const cacheKeys = Object.keys(localStorage).filter(key => key.startsWith('analysis_'));
                cacheKeys.forEach(key => localStorage.removeItem(key));
                console.log(`Cleared ${cacheKeys.length} cache entries`);
                return cacheKeys.length;
            } catch (error) {
                console.warn('Error clearing cache:', error);
                return 0;
            }
        }
        
        function getCacheStats() {
            try {
                const cacheKeys = Object.keys(localStorage).filter(key => key.startsWith('analysis_'));
                const now = new Date().getTime();
                let validEntries = 0;
                let expiredEntries = 0;
                
                cacheKeys.forEach(key => {
                    try {
                        const cached = JSON.parse(localStorage.getItem(key));
                        if (cached.timestamp && (now - cached.timestamp) > (CACHE_EXPIRY_DAYS * 24 * 60 * 60 * 1000)) {
                            expiredEntries++;
                        } else {
                            validEntries++;
                        }
                    } catch {
                        expiredEntries++;
                    }
                });
                
                return {
                    total: cacheKeys.length,
                    valid: validEntries,
                    expired: expiredEntries,
                    maxSize: MAX_CACHE_SIZE,
                    expiryDays: CACHE_EXPIRY_DAYS
                };
            } catch (error) {
                console.warn('Error getting cache stats:', error);
                return { total: 0, valid: 0, expired: 0, maxSize: MAX_CACHE_SIZE, expiryDays: CACHE_EXPIRY_DAYS };
            }
        }
        
        function updateCacheStats() {
            const stats = getCacheStats();
            const statsElement = document.getElementById('cacheStats');
            if (statsElement) {
                statsElement.innerHTML = `
                    <div class="cache-stat">
                        <strong>Total entries:</strong> ${stats.total}/${stats.maxSize}
                    </div>
                    <div class="cache-stat">
                        <strong>Valid entries:</strong> ${stats.valid}
                    </div>
                    <div class="cache-stat">
                        <strong>Expired entries:</strong> ${stats.expired}
                    </div>
                    <div class="cache-stat">
                        <strong>Expires after:</strong> ${stats.expiryDays} days
                    </div>
                `;
            }
        }
        
        function clearAllCacheAndUpdate() {
            const clearedCount = clearAllCache();
            updateCacheStats();
            
            // Show success message
            const successMsg = document.getElementById('uploadSuccess');
            if (successMsg) {
                successMsg.style.display = 'block';
                successMsg.textContent = `✅ Cleared ${clearedCount} cache entries.`;
            }
        }
        
        function clearExpiredCache() {
            clearOldCacheEntries();
            updateCacheStats();
            
            // Show success message
            const successMsg = document.getElementById('uploadSuccess');
            if (successMsg) {
                successMsg.style.display = 'block';
                successMsg.textContent = `✅ Cleared expired cache entries.`;
            }
        }

        // Geneva Bible Search Integration
        let bibleSearch = null;

        // Initialize Geneva Bible search when the app starts
        async function initializeBibleSearch() {
            try {
                const response = await fetch('/Public/Data/bibleSearch.js');
                if (response.ok) {
                    // Load the script dynamically
                    const script = document.createElement('script');
                    script.src = '/Public/Data/bibleSearch.js';
                    document.head.appendChild(script);
                    
                    // Wait for script to load and initialize
                    script.onload = async function() {
                        if (typeof BibleSearch !== 'undefined') {
                            bibleSearch = new BibleSearch();
                            const success = await bibleSearch.loadBibleData();
                            if (success) {
                                console.log('Geneva Bible search initialized successfully');
                                // Test the search functionality
                                const testResult = bibleSearch.searchBiblePassages('heaven and earth', 'Test Play', 1);
                                console.log('Geneva Bible search test result:', testResult);
                            } else {
                                console.warn('Failed to initialize Geneva Bible search');
                            }
                        }
                    };
                } else {
                    console.warn('Bible search script not found, continuing without Geneva Bible functionality');
                }
            } catch (error) {
                console.warn('Error loading Geneva Bible search:', error);
                // Continue without Bible search - this is not critical
            }
        }

        // Initialize Geneva Bible search when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeBibleSearch();
            // Initialize meta line
            updateMetaLine();
            
            // Initialize cache - clear expired entries on page load
            clearOldCacheEntries();
        });

        // Function to get Geneva Bible context for analysis
        async function getGenevaBibleContextForAnalysis(text, playName, level) {
            if (!bibleSearch || !bibleSearch.isLoaded) {
                console.log('Geneva Bible search not available');
                return null;
            }

            try {
                const bibleContext = bibleSearch.getBibleContext(text, playName, level);
                if (bibleContext && bibleContext.passages && bibleContext.passages.length > 0) {
                    return bibleSearch.formatBibleContextForPrompt(bibleContext);
                }
            } catch (error) {
                console.error('Error getting Geneva Bible context:', error);
            }
            
            return null;
        }

    </script>

    <!-- Footer About Section -->
    <footer class="footer-about">
        <div class="footer-title">About This Project</div>
        <div>
            Shakespeare Digital Variorum combines centuries of scholarly commentary with AI analysis.
            All Shakespeare texts are public domain and based on the Folger Shakespeare Library editions.
        </div>
        <div>
            Created by Jack David Carson, Massachusetts Institute of Technology · 2025 ·
            <a href="#" onclick="openRights(); return false;">Full Rights & Usage Information</a>
        </div>
    </footer>
</body>
</html>

