<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shakespeare Digital Variorum</title>
    <link rel="stylesheet" href="styles/tokens.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            letter-spacing: 0.005em;
            transition: background-color .18s ease, color .18s ease, border-color .18s ease, box-shadow .18s ease;
        }

        ::selection {
            background: var(--hl);
        }

        html, body {
            background: var(--bg);
            color: var(--ink-1);
            font-family: var(--ui);
            line-height: 1.6;
            min-height: 100vh;
            scroll-behavior: smooth;
        }

        body, button, input, select {
            font-family: "Inter", "SF Pro Text", system-ui, sans-serif;
            letter-spacing: .005em;
        }

        ::selection {
            background: var(--hl);
        }

        .container {
            max-width: 1320px;
            margin: 0 auto;
            padding: 0 var(--s-4);
        }

        .panel {
            background: var(--surface);
            border: 1px solid var(--line);
            border-radius: var(--r-sm);
            box-shadow: var(--shadow);
        }

        hr {
            border: 0;
            height: 1px;
            background: var(--line);
            margin: var(--s-4) 0;
        }

        /* Header */
        .header {
            position: sticky;
            top: 0;
            z-index: 20;
            backdrop-filter: saturate(180%) blur(10px);
            background: rgba(247,247,248,.85);
            border-bottom: 1px solid var(--line);
            padding: var(--s-3) var(--s-4);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header .brand {
            font-weight: 700;
            letter-spacing: .01em;
        }



        .header h1 {
            font-size: 1.8em;
            color: var(--ink-1);
            font-weight: 600;
            font-family: var(--ui);
        }

        .header-nav {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .nav-btn {
            background: none;
            border: none;
            color: var(--ink-2);
            cursor: pointer;
            padding: 10px 16px;
            border-radius: var(--r-sm);
            font-size: 15px;
            font-weight: 500;
            font-family: var(--ui);
        }

        .nav-btn:hover {
            background: var(--panel);
            color: var(--ink-1);
        }

        .btn {
            border-radius: 12px;
            font-weight: 600;
            transition: filter .15s, transform .08s;
            cursor: pointer;
        }

        .btn-primary {
            border: 1px solid rgba(0,0,0,.06);
            background: #000000;
            color: #fff;
            padding: 10px 14px;
        }

        .btn-primary:hover {
            background: #333333;
        }

        .btn-primary:active {
            transform: translateY(1px);
            background: #1a1a1a;
        }

        .btn-ghost {
            background: var(--surface);
            color: var(--ink-2);
            border: 1px solid var(--line);
            padding: 8px 12px;
        }

        .btn-ghost:hover {
            background: #F2F4F7;
            color: var(--ink-1);
        }

        .explain-btn:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Contextual Toolbar */
        #selectionToolbar {
            position: absolute;
            transform: translate(-50%,-120%);
            padding: 6px;
            border-radius: 12px;
            gap: 6px;
            background: var(--surface);
            border: 1px solid var(--line);
            box-shadow: var(--shadow);
            display: none;
            align-items: center;
            z-index: 1000;
            pointer-events: auto;
            max-width: 200px;
            white-space: nowrap;
        }

        /* Constrain toolbar to reading pane */
        .reader {
            position: relative;
            overflow: visible;
        }

        .reader #selectionToolbar {
            position: absolute;
            left: 50%;
            top: 0;
            transform: translate(-50%, -100%);
            margin-top: -10px;
        }

        /* Prevent toolbar from appearing in sidebar */
        .sidebar #selectionToolbar {
            display: none !important;
        }

        /* Ensure toolbar only appears in reading area */
        .reader #selectionToolbar {
            display: flex;
            position: absolute;
            left: 50%;
            top: 0;
            transform: translate(-50%, -100%);
            margin-top: -10px;
        }

        /* Prevent toolbar from appearing in analysis panel */
        .analysis #selectionToolbar {
            display: none !important;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background: var(--surface);
            border: 1px solid var(--line);
            border-radius: var(--r-lg);
            box-shadow: var(--shadow);
            padding: var(--s-5);
            max-width: 820px;
            margin: 0 auto;
            position: relative;
            top: 50%;
            transform: translateY(-50%);
            max-height: 90vh;
            overflow: hidden;
            animation: modalIn .18s ease-out;
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--s-4);
        }

        .modal-title {
            font: 700 20px/1.2 Inter, system-ui;
            letter-spacing: -.01em;
            color: var(--ink-1);
        }

        .modal-close {
            background: transparent;
            border: 0;
            color: var(--ink-3);
            font-size: 20px;
            border-radius: 10px;
            padding: 6px;
            cursor: pointer;
        }

        .modal-close:hover {
            background: rgba(0,0,0,.05);
        }

        .modal-body {
            max-height: calc(90vh - 140px);
            overflow: auto;
            padding-right: var(--s-2);
        }

        .modal-footer {
            display: flex;
            justify-content: center;
            gap: var(--s-2);
            margin-top: var(--s-4);
            padding-top: var(--s-4);
            border-top: 1px solid var(--line);
        }

        .close-settings-btn {
            background: #000000;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            font-family: Inter, system-ui, sans-serif;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .close-settings-btn:hover {
            background: #333333;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        /* Focus ring & entry motion */
        .modal :focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
            border-radius: 6px;
        }

        @keyframes modalIn {
            from {
                transform: translateY(6px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* About content rhythm */
        .about h2 {
            font: 600 16px Inter, system-ui;
            color: var(--ink-1);
            margin: var(--s-4) 0 var(--s-2);
        }

        .about p {
            color: var(--ink-2);
            font-size: 16px;
            line-height: 1.6;
            margin: 0 0 var(--s-3);
        }

        .about .meta {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--s-3);
            margin: var(--s-4) 0;
        }

        .about .badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border: 1px solid var(--line);
            border-radius: 12px;
            background: var(--surface);
        }

        .about .callout {
            background: #F2F4F7;
            border: 1px solid var(--line);
            border-radius: 12px;
            padding: var(--s-3);
            color: var(--ink-2);
        }

        .about ul {
            margin: 0 0 var(--s-3) 1.1rem;
            color: var(--ink-2);
        }

        .about a {
            color: var(--accent);
            text-decoration: none;
        }

        .about a:hover {
            text-decoration: underline;
        }

        /* Settings layout + controls */
        .settings {
            display: grid;
            grid-template-columns: 220px 1fr;
            gap: var(--s-4);
        }

        .settings-nav {
            background: var(--panel);
            border: 1px solid var(--line);
            border-radius: var(--r-lg);
            padding: var(--s-3);
        }

        .settings-nav .item {
            padding: 10px 12px;
            border-radius: 12px;
            color: var(--ink-2);
            cursor: pointer;
        }

        .settings-nav .item:hover {
            background: #ECEFF3;
        }

        .settings-nav .item.active {
            background: var(--surface);
            border: 1px solid var(--line);
            box-shadow: var(--shadow);
            color: var(--ink-1);
        }

        .settings-pane {
            background: var(--surface);
            border: 1px solid var(--line);
            border-radius: var(--r-lg);
            box-shadow: var(--shadow);
            padding: var(--s-5);
        }

        .settings-pane h3 {
            font: 600 16px Inter;
            margin: 0 0 var(--s-2);
            color: var(--ink-1);
        }

        .settings-pane .sub {
            color: var(--ink-3);
            margin: 0 0 var(--s-3);
        }

        .settings-pane .row {
            display: grid;
            grid-template-columns: 220px 1fr;
            gap: var(--s-3);
            align-items: center;
            padding: 12px 0;
        }

        .settings-pane .row + .row {
            border-top: 1px solid var(--line);
        }

        /* Controls (inputs, selects, toggles, file) */
        .input, .select, .textarea {
            width: 100%;
            background: var(--surface);
            color: var(--ink-1);
            border: 1px solid var(--line);
            border-radius: 12px;
            padding: 10px 12px;
            transition: border-color .15s, box-shadow .15s;
        }

        .input:focus, .select:focus, .textarea:focus {
            border-color: #C7D7FE;
            box-shadow: 0 0 0 3px rgba(59,130,246,.15);
        }

        .toggle {
            position: relative;
            width: 44px;
            height: 26px;
            background: #E6E8EE;
            border-radius: 999px;
            transition: background .15s;
        }

        .toggle:after {
            content: "";
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #fff;
            box-shadow: var(--shadow);
            transition: left .15s;
        }

        .toggle[aria-checked="true"] {
            background: #C7D7FE;
        }

        .toggle[aria-checked="true"]::after {
            left: 21px;
        }

        .dropzone {
            border: 1px dashed var(--line);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            color: var(--ink-3);
        }

        .dropzone:hover {
            background: #F6F7FA;
        }

        .settings-actions {
            display: flex;
            justify-content: flex-end;
            gap: var(--s-2);
            margin-top: var(--s-4);
        }

        .danger {
            border: 1px solid #F2C6C6;
            background: #FFF6F6;
            color: #8C2F2F;
            border-radius: 12px;
            padding: var(--s-3);
        }

        .upload-section, .library-section {
            margin-bottom: 25px;
        }

        .upload-section h3, .library-section h3 {
            margin-bottom: 15px;
            color: var(--ink-1);
            font-size: 1.3em;
            font-weight: 600;
            font-family: var(--ui);
        }

        .upload-section h4 {
            margin: 20px 0 10px 0;
            color: var(--ink-1);
            font-size: 1.1em;
            font-weight: 600;
            font-family: var(--ui);
        }

        .single-upload, .bulk-upload {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .play-name-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e9ecef;
        }

        .play-name-section label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--ink-1);
            font-family: var(--ui);
        }

        .name-instructions {
            font-size: 12px;
            color: var(--ink-3);
            margin-top: 8px;
            font-style: italic;
            font-family: var(--ui);
        }

        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .play-input {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid var(--line);
            border-radius: 4px;
            font-family: var(--ui);
            font-size: 14px;
        }

        .add-btn, .update-btn {
            background: #000000;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }

        .add-btn:hover, .update-btn:hover {
            background: #333333;
        }

        .file-upload {
            border: 2px dashed #e2e8f0;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            transition: all 0.3s ease;
        }

        .file-upload:hover {
            border-color: #000000;
            background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%);
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        }

        .file-upload input[type="file"] {
            display: none;
        }

        .file-upload label {
            cursor: pointer;
            color: #000000;
            font-weight: 600;
            font-size: 1.1em;
            display: block;
            margin-bottom: 10px;
        }

        .file-upload label:hover {
            text-decoration: underline;
        }

        .upload-instructions {
            margin-top: 10px;
            font-size: 14px;
            color: var(--ink-3);
            font-family: var(--ui);
        }

        .uploaded-plays, .library-plays {
            margin-top: 20px;
        }

        .play-item, .library-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
            margin-bottom: 8px;
            border: 1px solid #e9ecef;
        }

        .play-name, .library-name {
            font-weight: 500;
            color: var(--ink-1);
            font-family: var(--ui);
        }

        .play-info {
            font-size: 12px;
            color: var(--ink-3);
            margin-top: 4px;
            font-family: var(--ui);
        }

        .remove-play, .delete-play {
            background: #dc3545;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
        }

        .remove-play:hover, .delete-play:hover {
            background: #c82333;
        }

        .library-item {
            background: white;
            border: 1px solid #dee2e6;
        }

        .library-item:hover {
            background: #f8f9fa;
        }

        .upload-success {
            background: #d4edda;
            color: #155724;
            padding: 10px 15px;
            border-radius: 4px;
            margin-top: 15px;
            border: 1px solid #c3e6cb;
            display: none;
        }

        .upload-error {
            background: #f8d7da;
            color: #721c24;
            padding: 10px 15px;
            border-radius: 4px;
            margin-top: 15px;
            border: 1px solid #f5c6cb;
            display: none;
        }

        .about-content {
            line-height: 1.8;
            color: #2d3748;
            font-size: 1.05em;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        .about-content p {
            margin-bottom: 25px;
            text-align: justify;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        .about-footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #e9ecef;
            text-align: center;
        }

        .about-footer p {
            margin-bottom: 0;
            color: #6c757d;
        }

        /* Footer About Section */
        .footer-about {
            background: var(--panel);
            border-top: 1px solid var(--line);
            padding: var(--s-4) var(--s-5);
            font-size: 14px;
            line-height: 1.5;
            color: var(--ink-3);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            gap: var(--s-2);
            box-shadow: 0 -1px 2px rgba(0, 0, 0, 0.03);
        }

        .footer-about h3 {
            font-family: Inter, system-ui, sans-serif;
            font-weight: 600;
            letter-spacing: 0.01em;
            color: var(--ink-2);
            margin-bottom: var(--s-2);
        }

        .footer-title {
            font-family: Inter, system-ui, sans-serif;
            font-weight: 600;
            letter-spacing: 0.01em;
            color: var(--ink-2);
            margin-bottom: var(--s-2);
        }

        .footer-about p {
            max-width: 800px;
            margin: 0 auto 15px auto;
            color: var(--ink-3);
            line-height: 1.6;
            text-align: left;
        }

        .footer-about a {
            color: #000000;
            text-decoration: none;
            font-weight: 500;
        }

        .footer-about a:hover {
            text-decoration: underline;
        }

        .footer-attribution {
            font-size: 0.9em;
            color: var(--ink-3);
            margin-top: 20px;
            text-align: center;
        }

        .footer-attribution a {
            color: var(--accent);
            text-decoration: none;
            font-weight: 500;
        }

        .footer-attribution a:hover {
            text-decoration: underline;
        }



        /* Rights Modal */
        .rights-content {
            line-height: 1.7;
            color: #495057;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        .rights-content h4 {
            color: #2d3748;
            margin: 30px 0 15px 0;
            font-size: 1.2em;
            font-weight: 600;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        .rights-content h4:first-child {
            margin-top: 0;
        }

        .rights-content p {
            margin-bottom: 20px;
            font-size: 15px;
        }

        .rights-footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #e9ecef;
            text-align: center;
        }

        .rights-footer h4 {
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .rights-footer p {
            margin-bottom: 5px;
            color: #6c757d;
        }

        .rights-footer a {
            color: #007bff;
            text-decoration: none;
        }

        .rights-footer a:hover {
            text-decoration: underline;
        }

        .close-rights-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 25px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 20px;
        }

        .close-rights-btn:hover {
            background: #0056b3;
        }

        .modal-close-btn {
            background: #000000;
            color: white;
            border: none;
            padding: 10px 25px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 20px;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .modal-close-btn:hover {
            background: #333333;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        /* Main Layout */
        .layout {
            display: grid;
            grid-template-columns: 280px 1fr minmax(400px, 35%);
            gap: var(--s-4);
            min-height: calc(100vh - 70px);
            background: var(--bg);
            position: relative;
        }

        @media (min-width: 1600px) {
            .layout {
                grid-template-columns: 280px 50% 30%;
            }
        }

        @media (max-width: 1200px) {
            .layout {
                grid-template-columns: 280px 1fr minmax(350px, 30%);
            }
        }

        @media (max-width: 900px) {
            .layout {
                grid-template-columns: 280px 1fr minmax(300px, 25%);
            }
        }

        /* Sidebar */
        .sidebar {
            background: var(--panel);
            border: 1px solid var(--line);
            border-radius: var(--r-lg);
            padding: var(--s-3) var(--s-2);
            position: sticky;
            top: var(--s-4);
            max-height: calc(100vh - var(--s-4) * 2);
            overflow: auto;
            box-shadow: var(--shadow);
        }

        /* top/bottom scroll cues like Apple */
        .sidebar::before,
        .sidebar::after {
            content: "";
            position: sticky;
            left: 0;
            right: 0;
            height: 12px;
            pointer-events: none;
            z-index: 1;
        }

        .sidebar::before {
            top: 0;
            box-shadow: inset 0 8px 8px -8px rgba(0,0,0,.08);
        }

        .sidebar::after {
            bottom: 0;
            box-shadow: inset 0 -8px 8px -8px rgba(0,0,0,.08);
        }

        /* === Sidebar Navigation Styling (Notion × Apple aesthetic) === */

        /* Reset link colors so visited links don't go purple */
        .sidebar a,
        .sidebar a:visited {
            color: var(--ink-2);
            text-decoration: none;
            display: block;
        }

        /* Hover and active styles */
        .sidebar a:hover {
            background: #ECEFF3;
            color: var(--ink-1);
        }

        .sidebar .active,
        .sidebar .active:visited {
            background: var(--surface);
            border: 1px solid var(--line);
            box-shadow: var(--shadow);
            color: var(--ink-1);
        }

        /* ACT headings (keep, replace "Navigation") */
        .nav-section-title {
            font: 600 12px/1 Inter, system-ui, sans-serif;
            letter-spacing: .06em;
            text-transform: uppercase;
            color: var(--ink-3);
            margin: var(--s-3) 0 var(--s-2);
            padding: 0 var(--s-2);
        }

        /* Scene links (no purple, no white-out; clear active) */
        /* unify colors; kill :visited purple */
        .sidebar a, .sidebar a:visited {
            color: var(--ink-2);
            text-decoration: none;
            display: block;
        }

        /* base item */
        .nav-item {
            padding: 8px 12px;
            margin: 2px 0;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 500;
            transition: background-color .15s ease, color .15s ease, box-shadow .15s ease, border-color .15s ease;
        }

        /* hover */
        .nav-item:hover {
            background: #ECEFF3;
            color: var(--ink-1);
        }

        /* active scene = floating chip/card (not white slab) */
        .nav-item.active,
        .nav-item[aria-current="page"] {
            background: var(--surface);
            color: var(--ink-1);
            border: 1px solid var(--line);
            box-shadow: var(--shadow);
        }

        /* selected ACT in the list can be slightly bolder */
        .nav-item.act {
            font-weight: 600;
        }

        /* Focus & a11y */
        .nav-item:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }

        /* Optional: tighter vertical rhythm */
        .nav-group {
            padding: 0 var(--s-2);
            margin-bottom: var(--s-3);
        }

        .play-selector-container {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .play-selector {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-family: inherit;
            font-size: 14px;
            min-width: 0; /* Allow flex item to shrink */
        }
        
        .play-selector option {
            word-wrap: break-word;
            white-space: normal;
            max-width: 200px;
        }
        
        .go-btn {
            padding: 8px 16px;
            background: #000000;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .go-btn:hover {
            background: #333333;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .cancel-btn {
            padding: 8px 16px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            margin-left: 8px;
        }
        
        .cancel-btn:hover {
            background-color: #545b62;
        }
        
        .bulk-rename-section {
            margin-top: 15px;
        }
        
        .bulk-rename-list {
            margin: 15px 0;
        }
        
        .bulk-rename-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        
        .bulk-rename-item label {
            min-width: 80px;
            font-weight: 500;
        }
        
        .bulk-name-input {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .original-filename {
            color: #6c757d;
            font-size: 12px;
            font-style: italic;
        }

        .navigation-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .navigation-list li {
            margin-bottom: 2px;
        }

        .navigation-list .sub-item {
            margin-left: 15px;
            font-size: 12px;
        }

        .navigation-list .sub-item a {
            padding: 4px 8px;
        }

        /* Reading Pane */
        .reader {
            background: var(--surface);
            padding: var(--s-5);
            overflow-y: auto;
            overflow-x: hidden;
            border: 1px solid var(--line);
            border-radius: var(--r-md);
            box-shadow: var(--shadow);
            max-width: 100%;
            word-wrap: break-word;
        }

        .scene-title {
            font-size: 1.4em;
            font-weight: 600;
            margin-bottom: 24px;
            color: #2d3748;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 14px;
        }

        .scene-separator {
            border-top: 1px solid rgba(0,0,0,0.08);
            margin: 24px 0;
        }

        .stage-direction {
            font-style: italic;
            color: #6b7280;
            margin: 16px 0;
            font-family: 'Charter', 'Georgia', 'Times New Roman', serif;
            font-size: 16px;
        }

        .dialogue {
            margin: 20px 0;
            padding: 12px 0;
        }

        .character-name {
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 12px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        .play {
            font-family: "Source Serif 4", "Georgia", serif;
            font-size: 13px;
            line-height: 1.5;
            max-width: 100%;
            margin: 0 auto;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }

        .play .scene-title {
            font-family: Inter;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: .06em;
            font-size: 13px;
            color: var(--ink-3);
            margin-bottom: var(--s-2);
        }

        .play .stage {
            font-style: italic;
            color: var(--ink-3);
        }

        .play .speaker {
            font-variant-caps: small-caps;
            letter-spacing: .04em;
        }

        /* Verse line styling - force wrapping for readability */
        .play .line {
            display: block;
            white-space: normal;
            word-break: break-all;
            overflow-wrap: break-word;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Stage directions and prose can still wrap nicely */
        .play .stage {
            font-style: italic;
            color: var(--ink-3);
            white-space: normal;
        }

        .play .prose {
            white-space: normal;
            max-width: 100%;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        /* Force container constraints */
        .reader * {
            max-width: 100% !important;
            box-sizing: border-box;
        }

        .play * {
            max-width: 100% !important;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        /* Responsive text sizing for different screen sizes */
        @media (max-width: 1200px) {
            .play {
                font-size: 12px;
            }
        }

        @media (max-width: 900px) {
            .play {
                font-size: 11px;
            }
        }

        @media (max-width: 600px) {
            .play {
                font-size: 10px;
            }
        }



        /* Graceful degradation on narrow screens */
        @media (max-width: 1200px) {
            .play, .play .line {
                white-space: pre-wrap;
            }
        }

        .dialogue-text {
            margin-left: 20px;
            line-height: 1.58;
            white-space: normal;
            font-family: var(--serif);
            font-size: 18px;
            max-width: 72ch;
            color: var(--ink-1);
        }

        .highlight {
            background: var(--hl);
            border-radius: 4px;
            transition: background .18s;
        }

        /* Analysis Mode Selector */
        .analysis-mode-selector {
            background: white;
            padding: 20px;
            border-radius: 6px 6px 0 0;
            border-bottom: 1px solid rgba(0,0,0,0.08);
            margin-bottom: 0;
        }

        .segment {
            display: inline-flex;
            background: var(--panel);
            border: 1px solid var(--line);
            border-radius: 999px;
            padding: 4px;
            gap: 4px;
        }

        .segment button {
            background: transparent;
            border: 0;
            padding: 8px 14px;
            border-radius: 999px;
            color: var(--ink-2);
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.15s ease, color 0.15s ease;
        }

        .segment button[aria-pressed="true"] {
            background: #000000;
            box-shadow: var(--shadow);
            color: #ffffff;
        }

        /* Analysis Pane — Notion × Apple formatting */
        .analysis {
            background: var(--surface);
            border: 1px solid var(--line);
            border-radius: var(--r-md);
            box-shadow: var(--shadow);
            padding: var(--s-5);
            font-family: "Source Serif 4", Georgia, serif;
            font-size: 17.5px;
            line-height: 1.65;
            color: var(--ink-1);
            max-width: 80ch;
            margin: 0;
            position: sticky;
            top: var(--s-4);
            align-self: start;
            max-height: calc(100vh - var(--s-4) * 2);
            overflow-y: auto;
        }

        /* Top meta line (play · act · scene · selection count) */
        .analysis .meta {
            font-family: Inter, system-ui, sans-serif;
            font-size: 13px;
            letter-spacing: .02em;
            color: var(--ink-3);
            margin-bottom: var(--s-3);
        }

        /* Section headings inside the answer */
        .analysis h3 {
            font-family: Inter, system-ui, sans-serif;
            font-weight: 600;
            font-size: 15px;
            color: var(--ink-2);
            margin: var(--s-4) 0 var(--s-2);
        }

        /* "Label — content" paragraphs (e.g., Plain-Language Paraphrase — …)  */
        .analysis .kv { 
            margin: 0 0 var(--s-3); 
        }
        .analysis .kv .k {
            font-family: Inter, system-ui, sans-serif;
            font-weight: 600;
            font-size: 15px;
            color: var(--ink-2);
            margin-right: .35rem;
        }
        .analysis .kv .sep { 
            margin-right: .35rem; 
            color: var(--ink-3); 
        } /* the em-dash */

        /* Lists with hanging bullets (Apple-ish) */
        .analysis ul { 
            margin: 0 0 var(--s-3);
            padding-left: 1.1rem;
        }
        .analysis ul li { 
            margin: .2rem 0; 
        }
        .analysis ul li::marker { 
            color: var(--ink-3); 
        }

        /* Definition list (for Key Words) */
        .analysis dl { 
            margin: 0 0 var(--s-3); 
        }
        .analysis dt {
            font-family: Inter, system-ui, sans-serif;
            font-weight: 600;
            color: var(--ink-2);
            display: inline;
        }
        .analysis dd {
            display: inline;
            margin: 0 0 0 .35rem;
            color: var(--ink-1);
        }
        .analysis dd + dt::before { 
            content: "\A"; 
            white-space: pre; 
        } /* next term on new line */

        /* Soft section dividers without boxing the content */
        .analysis .section + .section {
            border-top: 1px solid var(--line);
            padding-top: var(--s-4);
            margin-top: var(--s-4);
        }

        /* Copy chip in the corner */
        .analysis .copy-chip {
            position: absolute;
            top: var(--s-3);
            right: var(--s-3);
            font-family: Inter, system-ui, sans-serif;
            font-size: 13px;
            color: var(--ink-2);
            background: var(--surface);
            border: 1px solid var(--line);
            border-radius: 999px;
            padding: 6px 10px;
            box-shadow: var(--shadow);
            cursor: pointer;
        }

        /* Quotes / citations inside the answer */
        .analysis blockquote {
            margin: var(--s-3) 0;
            padding-left: 1rem;
            border-left: 3px solid var(--line);
            color: var(--ink-2);
            font-style: italic;
        }

        /* Micro-typography */
        .analysis p, .analysis li { 
            text-rendering: optimizeLegibility; 
            font-feature-settings: "liga","clig","kern";
        }

        /* Dense mode for long outputs (optional toggle) */
        .analysis.compact { 
            font-size: 16.5px; 
            line-height: 1.55; 
            max-width: 86ch; 
        }

        .analysis p {
            margin-bottom: var(--s-3);
            text-rendering: optimizeLegibility;
            font-feature-settings: "liga", "clig", "kern";
        }

        .analysis ul, .analysis ol {
            padding-left: 1.2rem;
            margin-bottom: var(--s-3);
        }

        .analysis-section + .analysis-section {
            border-top: 1px solid var(--line);
            padding-top: var(--s-4);
            margin-top: var(--s-4);
        }

        /* Analysis panel specific elements */
        .analysis .segment {
            margin-bottom: var(--s-4);
        }

        .analysis .analysis-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--s-2);
        }

        .analysis .analysis-title {
            font-family: Inter, system-ui, sans-serif;
            font-weight: 600;
            font-size: 16px;
            color: var(--ink-1);
        }

        .analysis .selection-info {
            font-family: Inter, system-ui, sans-serif;
            font-size: 14px;
            color: var(--ink-3);
            margin-bottom: var(--s-3);
        }

        .analysis .copy-btn {
            background: transparent;
            border: 1px solid var(--line);
            border-radius: var(--r-sm);
            padding: 6px 12px;
            font-size: 12px;
            color: var(--ink-2);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .analysis .copy-btn:hover {
            background: var(--panel);
            color: var(--ink-1);
        }

        /* Researching animation */
        .researching {
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        /* Analyzing message styling */
        .analyzing-message {
            font-family: Inter, system-ui, sans-serif;
            font-size: 20px;
            line-height: 1.6;
            color: var(--ink-1);
            text-align: center;
            margin: 40px 0;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        /* Shakespeare thinking icon */
        .shakespeare-icon {
            width: 32px;
            height: 32px;
            object-fit: contain;
            vertical-align: middle;
        }

        .analysis .follow-up-input {
            display: flex;
            gap: var(--s-2);
            margin-top: var(--s-2);
        }

        .analysis .follow-up-input input {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid var(--line);
            border-radius: var(--r-sm);
            font-family: Inter, system-ui, sans-serif;
            font-size: 14px;
        }

        .analysis .follow-up-input input:focus {
            border-color: var(--accent);
            outline: none;
            box-shadow: 0 0 0 3px rgba(59,130,246,.15);
        }

        /* Ask button styling */
        .ask-btn {
            border-radius: 999px;
            font-weight: 600;
            padding: 8px 16px;
            background: #000000;
            border: none;
            color: #fff;
            transition: background-color 0.15s ease, transform 0.08s ease;
        }

        .ask-btn:hover {
            background: #333333;
        }

        .ask-btn:active {
            transform: translateY(1px);
            background: #1a1a1a;
        }

        /* Base style for all link buttons */
        .link-btn {
            display: block;
            width: 100%;
            padding: 10px 14px;
            border-radius: var(--r-md);
            font-size: 14px;
            font-weight: 500;
            text-align: left;
            color: var(--ink-1);
            transition: background-color 0.15s ease, color 0.15s ease, box-shadow 0.15s ease;
            border: 1px solid var(--line);
        }

        /* Default neutral for non-branded links */
        .link-btn.default {
            background: var(--panel);
        }

        .link-btn.default:hover {
            background: #E8EAED;
        }

        /* All link buttons use default grey styling */
        .link-btn.youtube,
        .link-btn.jstor,
        .link-btn.scholar,
        .link-btn.ise {
            background: var(--panel);
            border-color: var(--border);
            color: var(--ink-1);
        }

        .link-btn.youtube:hover,
        .link-btn.jstor:hover,
        .link-btn.scholar:hover,
        .link-btn.ise:hover {
            background: #E8EAED;
        }

        /* AI Analysis Content */
        .ai-analysis-content {
            background: white;
            padding: 20px;
            margin: 0;
            border-radius: 0;
            box-shadow: none;
            border: none;
        }

        /* Media Section */
        .media-section {
            background: white;
            padding: 20px;
            border-top: 1px solid rgba(0,0,0,0.08);
            margin: 0;
        }

        .media-links {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
        }

        .list a {
            display: block;
            padding: 10px 12px;
            border-radius: 10px;
            color: var(--ink-2);
            text-decoration: none;
            font-family: var(--ui);
            font-size: 14px;
            transition: background-color 0.2s ease;
        }

        .list a:hover {
            background: #EFF2F7;
            color: var(--ink-1);
        }

        .media-actions {
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
        }

        .research-actions {
            display: flex;
            flex-direction: column;
            gap: var(--s-2);
        }

        /* Empty State */
        .empty {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 50vh;
        }

        .empty-body {
            display: flex;
            flex-direction: column;
            gap: var(--s-3);
            align-items: center;
            text-align: center;
        }

        .empty-title {
            font-weight: 700;
            font-family: Inter, system-ui, sans-serif;
        }

        .empty-sub {
            color: var(--ink-3);
        }

        /* Spacing/rhythm cleanup */
        .panel > * + * {
            margin-top: var(--s-3);
        }

        .section > * + * {
            margin-top: var(--s-2);
        }

        /* Research Section */
        .research-section {
            background: white;
            padding: 20px;
            border-top: 1px solid rgba(0,0,0,0.08);
            margin: 0;
        }

        .research-links {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
        }

        .research-link {
            color: #3B82F6;
            text-decoration: underline;
            font-size: 14px;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .research-link:hover {
            color: #2563EB;
        }

        .card {
            background: var(--surface);
            border: 1px solid var(--line);
            border-radius: var(--r-sm);
            padding: var(--s-4);
            box-shadow: var(--shadow);
            margin-bottom: var(--s-4);
        }

        .card h3 {
            font-weight: 600;
            color: var(--ink-2);
            margin: 0 0 var(--s-2);
        }

        .analysis-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .analysis-title {
            font-weight: 600;
            font-size: 16px;
            color: #2d3748;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        .copy-btn {
            background: none;
            border: 1px solid #ced4da;
            color: #6c757d;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }

        .copy-btn:hover {
            background: #f8f9fa;
        }

        .selection-info {
            font-size: 14px;
            color: #6c757d;
            margin-bottom: 15px;
        }

        .analysis-content {
            font-size: 14px;
            line-height: 1.7;
            color: #2d3748;
            font-family: 'Georgia', 'Times New Roman', serif;
        }

        .analysis-content p {
            margin-bottom: 15px;
        }

        .analysis-section h4 {
            font-size: 16px;
            font-weight: 700;
            color: #1a202c;
            margin: 20px 0 10px 0;
            font-family: 'Georgia', 'Times New Roman', serif;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 5px;
        }

        .analysis-section h4:first-of-type {
            margin-top: 0;
        }

        .quoted-text {
            background: #f8f9fa;
            border-left: 3px solid #007bff;
            padding: 10px 15px;
            margin: 15px 0;
            font-style: italic;
        }

        .follow-up-section {
            background: white;
            padding: 20px;
            border-top: 1px solid rgba(0,0,0,0.08);
            border-radius: 0 0 6px 6px;
            margin-top: 0;
        }

        .follow-up-input {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .follow-up-input input {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-family: inherit;
            font-size: 14px;
        }



        /* Responsive Design */
        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 250px 1fr 350px;
            }
        }

        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
                height: auto;
            }
            
            .left-panel, .right-panel {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <h1>Shakespeare Digital Variorum</h1>
        <div class="header-nav">
            <button class="nav-btn" onclick="openSettings()">Settings</button>
            <button class="nav-btn" onclick="openAbout()">About</button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Settings</div>
                <button class="modal-close" onclick="closeSettings()">&times;</button>
            </div>
            
            <div class="modal-body">
                <div class="upload-section">
                    <h3>Add Play to Library</h3>
                    
                    <!-- Single Play Upload -->
                    <div class="single-upload">
                        <h4>Upload Single Play</h4>
                        <div class="file-upload">
                            <input type="file" id="playFile" accept=".xml,.txt" onchange="handleFileUpload(event)">
                            <label for="playFile">Choose a play file (.xml or .txt)</label>
                            <div class="upload-instructions">
                                Upload TEISimple XML files (with MorphAdorner annotations) or .txt files containing Shakespeare play text. The system will automatically parse them into acts, scenes, and characters with enhanced linguistic analysis.
                            </div>
                        </div>
                        <div class="play-name-section" id="playNameSection" style="display: none;">
                            <label for="playNameInput">Name of play:</label>
                            <div class="input-group">
                                <input type="text" id="playNameInput" placeholder="Enter play name (e.g., Hamlet, Romeo and Juliet)" class="play-input">
                                <button onclick="addPlayToLibrary();" class="add-btn" id="addPlayBtn" style="cursor: pointer;">Add Play</button>
                                <button onclick="cancelUpload();" class="cancel-btn" style="cursor: pointer;">Cancel</button>
                            </div>
                            <div class="name-instructions">
                                The system detected the play name above. You can modify it if needed, then click "Add Play" to add it to your library.
                            </div>
                        </div>
                        
                        <div class="upload-success" id="uploadSuccess">
                            ✅ Play uploaded successfully! You can now select it from the Library dropdown.
                        </div>
                    </div>
                    
                    <!-- Bulk Upload -->
                    <div class="bulk-upload">
                        <h4>Bulk Upload Multiple Plays</h4>
                        <div class="file-upload">
                            <input type="file" id="bulkPlayFiles" accept=".xml,.txt" multiple onchange="handleBulkUpload(event)">
                            <label for="bulkPlayFiles">Choose multiple play files (.xml or .txt)</label>
                            <div class="upload-instructions">
                                Select multiple TEISimple XML files (with MorphAdorner annotations) or .txt files to upload several plays at once with enhanced linguistic analysis.
                            </div>
                        </div>
                    </div>
                    
                    <div class="upload-error" id="uploadError">
                        ❌ Error uploading play. Please try again.
                    </div>
                </div>
                
                <!-- Library Management Section -->
                <div class="library-section">
                    <h3>Manage Library</h3>
                    <div class="library-plays" id="libraryPlays">
                        <!-- Library plays will appear here -->
                    </div>
                </div>
                
                <!-- Close Button -->
                <div class="modal-footer">
                    <button class="close-settings-btn" onclick="closeSettings()">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- About Modal -->
    <div id="aboutModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">About This Project</div>
                <button class="modal-close" onclick="closeAbout()">&times;</button>
            </div>
            
            <div class="modal-body">
                <div class="about">
                    <p>The New Variorum Shakespeare editions have been the gold standard of Shakespearean scholarship for over a century, bringing together the most important critical commentary, textual analysis, and historical context in comprehensive annotated volumes. The Shakespeare Digital Variorum builds on this tradition, harnessing the power of artificial intelligence to make centuries of scholarly insight accessible to everyone, from high school students to veteran researchers.</p>
                    
                    <p>Our platform integrates authoritative texts based on the Folger Shakespeare Library editions of each play, with commentary from major variorum editions, scholarly databases, and historical sources. We include references to film adaptations, stage productions, and cultural interpretations that show how Shakespeare's works have lived and evolved across different media and eras. Using advanced AI, we can instantly provide plain-language explanations of complex passages, trace the etymology of Early Modern English words as they appear in context, analyze prosodic patterns across scenes and plays, and illuminate the historical events and cultural forces that shaped each work.</p>
                    
                    <p>The goal is radical accessibility. Whether you're encountering Hamlet's soliloquies for the first time or you're a seasoned scholar investigating textual variants, the Shakespeare Digital Variorum meets you where you are. Students can receive immediate clarification of archaic language and historical references. Researchers can discover thematic connections across the complete canon. Theater practitioners can access centuries of performance history, from Garrick to Branagh to contemporary productions worldwide.</p>
                    
                    <p>We believe Shakespeare belongs to everyone, not just academics. By connecting scholarly commentary with film clips, performance videos, and multimedia resources, we show how these 400-year-old plays continue to speak to modern audiences. A teenager reading Romeo and Juliet can instantly see how Baz Luhrmann reimagined the balcony scene, while a graduate student can access the full textual apparatus from multiple critical editions.</p>
                    
                    <p>This isn't about replacing human scholarship but about democratizing it. Every AI-generated insight is grounded in the work of generations of Shakespeare scholars, from the earliest editors to contemporary critics. We've simply made it possible for anyone to access that collective wisdom instantly, searchably, and in conversation with the texts themselves.</p>
                    
                    <p>The Shakespeare Digital Variorum represents the next evolution of the variorum tradition: comprehensive, scholarly, and designed for universal access. Shakespeare's world is vast, and now everyone can explore all of it.</p>
                    
                    <p><em>Created by Jack David Carson, Massachusetts Institute of Technology • 2025</em></p>

                    <div class="meta">
                        <div class="badge">Version <strong>1.0.0</strong></div>
                        <div class="badge">Build <span id="build-id">auto</span></div>
                        <div class="badge">Texts: Folger base</div>
                        <div class="badge">Commentary: NVSh + secondary</div>
                    </div>

                    <h2>Purpose</h2>
                    <p>Bring variorum-grade scholarship to a modern, accessible reading tool powered by AI.</p>

                    <h2>What's inside</h2>
                    <ul>
                        <li>Authoritative texts (Folger editions).</li>
                        <li>Cross-references to major variorum editions and scholarly databases.</li>
                        <li>AI explanations, paraphrase, performance notes, and research links.</li>
                    </ul>

                    <div class="callout">
                        We do not replace editors. AI outputs are aids; verify before citing.
                    </div>

                    <h2>Sources & Attribution</h2>
                    <ul>
                        <li>Texts: Folger Shakespeare Library.</li>
                        <li>Commentary indices: New Variorum Shakespeare series.</li>
                        <li>External: JSTOR, Google Scholar, Internet Shakespeare Editions.</li>
                    </ul>

                    <h2>Contact & License</h2>
                    <p>Issues or corrections: <a href="mailto:jack@example.com">email</a>. License: CC BY-NC-SA 4.0 - Free to use for non-commercial, educational purposes with attribution.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Rights & Attribution Modal -->
    <div id="rightsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Rights & Attribution</div>
                <span class="close" onclick="closeRights()">&times;</span>
            </div>
            
            <div class="modal-body">
                <div class="rights-content">
                    <h4>Shakespeare Texts</h4>
                    <p>Public domain. Based on editions from the Folger Shakespeare Library and other scholarly sources.</p>
                    
                    <h4>Scholarly Commentary</h4>
                    <p>Used under fair use for educational purposes. Sources include JSTOR, academic publications, and historical editions. Full citations provided with each annotation.</p>
                    
                    <h4>This Website</h4>
                    <p>Licensed under CC BY-NC-SA 4.0 - Free to use for non-commercial, educational purposes with attribution.</p>
                    
                    <h4>AI Analysis</h4>
                    <p>Generated content is provided for educational purposes. Users should verify information with primary sources.</p>
                    
                    <div class="rights-footer">
                        <h4>Shakespeare Digital Variorum</h4>
                        <p>Created by Jack David Carson, Massachusetts Institute of Technology • 2025</p>
                        <p>Questions about usage? Contact: <a href="mailto:jdcarson@mit.edu">jdcarson@mit.edu</a></p>
                        <button class="close-rights-btn" onclick="closeRights()">Close</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="layout">
        <!-- Sidebar -->
        <aside class="sidebar" aria-label="Play navigation">
            <div class="section-title">Library</div>
            <div class="play-selector-container">
                <select class="play-selector" id="playSelector">
                    <option value="" disabled selected>Choose a Play</option>
                </select>
                <button onclick="loadSelectedPlay()" class="go-btn">Go</button>
            </div>

            <ul class="navigation-list" id="navigationList" aria-label="Play navigation">
                <!-- Navigation will be populated dynamically -->
            </ul>
        </aside>

        <!-- Reading Pane -->
        <div class="reader panel play" id="playText">
            <div class="empty card">
                <div class="empty-body">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#6B7078" stroke-width="1.5"><circle cx="12" cy="12" r="9"/><path d="M8 13h8M8 10h5"/></svg>
                    <div class="empty-title">Add a play to begin</div>
                    <div class="empty-sub">Upload a text file in Settings. We'll auto-index acts and scenes.</div>
                    <button class="btn btn-primary" onclick="openSettings()">Open Settings</button>
                </div>
            </div>
        </div>

        <!-- Analysis Pane -->
        <div class="analysis panel" id="analysisPanel">
            <!-- Analysis Mode Selector -->
            <div class="segment">
                <button onclick="setAnalysisMode('basic')" aria-pressed="true">Basic</button>
                <button onclick="setAnalysisMode('intermediate')" aria-pressed="false">Intermediate</button>
                <button onclick="setAnalysisMode('expert')" aria-pressed="false">Expert</button>
                <button onclick="setAnalysisMode('fullfathomfive')" aria-pressed="false">Full Fathom Five</button>
            </div>

            <!-- AI Analysis Content -->
            <div class="analysis-header">
                <div class="analysis-title">Basic Analysis</div>
                <button class="copy-btn" onclick="copyAnalysis()">Copy</button>
            </div>
            <div class="selection-info">No text selected</div>
            <div class="analysis-content">
                <p>Highlight text in the play to get AI-powered analysis.</p>
            </div>

            <!-- Media Section -->
            <h3>Media</h3>
            <div class="media-actions">
                <button class="link-btn youtube" onclick="searchYouTube('scene')">Search YouTube for this scene</button>
            </div>

            <!-- Research Section -->
            <h3>Research</h3>
            <div class="research-actions">
                <button class="link-btn jstor" onclick="searchJSTOR('exact')">Search JSTOR for exact quotation</button>
                <button class="link-btn jstor" onclick="searchJSTOR('passage')">Search JSTOR for this passage/scene</button>
                <button class="link-btn scholar" onclick="searchGoogleScholar()">Google Scholar</button>
                <button class="link-btn ise" onclick="openInternetShakespeare()">Internet Shakespeare Editions</button>
            </div>

            <!-- Follow-up Section -->
            <h3>Ask a follow-up question</h3>
            <div class="follow-up-input">
                <input type="text" placeholder="Ask a follow-up question..." id="followUpQuestion">
                <button class="ask-btn" onclick="askFollowUp()">Ask</button>
            </div>
        </div>
    </div>

    <!-- Contextual Toolbar -->
    <div id="selectionToolbar" class="panel" hidden>
        <button class="btn btn-primary" id="explainBtn">Explain</button>
        <button class="btn btn-ghost" id="copyBtn">Copy</button>
    </div>

    <script>
        let selectedText = '';
        let plays = {};
        let currentPlay = '';
        let currentScene = '';

        // Modal functions
        function openSettings() {
            document.getElementById('settingsModal').style.display = 'block';
            
            // Hide any existing success/error messages when opening settings
            document.getElementById('uploadSuccess').style.display = 'none';
            document.getElementById('uploadError').style.display = 'none';
            
            // Hide the contextual toolbar when opening settings
            const toolbar = document.getElementById('selectionToolbar');
            if (toolbar) {
                toolbar.hidden = true;
            }
            
            updateLibraryPlays(); // Refresh the library display
        }

        function closeSettings() {
            console.log('closeSettings called');
            const modal = document.getElementById('settingsModal');
            console.log('Settings modal element:', modal);
            if (modal) {
                modal.style.display = 'none';
                console.log('Settings modal hidden');
            } else {
                console.error('Settings modal not found');
            }
        }

        function openAbout() {
            document.getElementById('aboutModal').style.display = 'block';
            
            // Hide the contextual toolbar when opening about
            const toolbar = document.getElementById('selectionToolbar');
            if (toolbar) {
                toolbar.hidden = true;
            }
        }

        function closeAbout() {
            document.getElementById('aboutModal').style.display = 'none';
        }

        function openRights() {
            document.getElementById('rightsModal').style.display = 'block';
            
            // Hide the contextual toolbar when opening rights
            const toolbar = document.getElementById('selectionToolbar');
            if (toolbar) {
                toolbar.hidden = true;
            }
        }

        function closeRights() {
            document.getElementById('rightsModal').style.display = 'none';
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const settingsModal = document.getElementById('settingsModal');
            const aboutModal = document.getElementById('aboutModal');
            const rightsModal = document.getElementById('rightsModal');
            if (event.target === settingsModal) {
                closeSettings();
            }
            if (event.target === aboutModal) {
                closeAbout();
            }
            if (event.target === rightsModal) {
                closeRights();
            }
        }

        // Settings navigation functionality
        document.addEventListener('DOMContentLoaded', function() {
            // Add ARIA attributes to modals
            const settingsModal = document.getElementById('settingsModal');
            const aboutModal = document.getElementById('aboutModal');
            
            if (settingsModal) {
                settingsModal.setAttribute('role', 'dialog');
                settingsModal.setAttribute('aria-modal', 'true');
                settingsModal.setAttribute('aria-labelledby', 'settings-modal-title');
            }
            
            if (aboutModal) {
                aboutModal.setAttribute('role', 'dialog');
                aboutModal.setAttribute('aria-modal', 'true');
                aboutModal.setAttribute('aria-labelledby', 'about-modal-title');
            }

            // Settings nav switching
            document.querySelectorAll('.settings-nav .item').forEach((el, i) => {
                el.addEventListener('click', () => {
                    document.querySelectorAll('.settings-nav .item').forEach(n => n.classList.remove('active'));
                    el.classList.add('active');
                    // For now, just highlight the active nav item
                    // In a full implementation, you'd show different panes
                });
            });

            // Escape key to close modals
            document.addEventListener('keydown', e => {
                if (e.key === 'Escape') {
                    if (settingsModal && settingsModal.style.display === 'block') {
                        closeSettings();
                    }
                    if (aboutModal && aboutModal.style.display === 'block') {
                        closeAbout();
                    }
                }
            });
        });

        // Detect play title from content and return in proper case
        function detectPlayTitle(content) {
            const lines = content.split('\n');
            
            // Common Shakespeare play titles for better matching
            const shakespeareTitles = [
                'HAMLET', 'ROMEO AND JULIET', 'MACBETH', 'KING LEAR', 'OTHELLO', 'A MIDSUMMER NIGHT\'S DREAM',
                'THE TEMPEST', 'AS YOU LIKE IT', 'TWELFTH NIGHT', 'MUCH ADO ABOUT NOTHING', 'THE MERCHANT OF VENICE',
                'JULIUS CAESAR', 'ANTONY AND CLEOPATRA', 'CORIOLANUS', 'TITUS ANDRONICUS', 'CYMBELINE',
                'THE WINTER\'S TALE', 'PERICLES', 'THE TWO GENTLEMEN OF VERONA', 'THE COMEDY OF ERRORS',
                'LOVE\'S LABOUR\'S LOST', 'A MIDSUMMER NIGHT\'S DREAM', 'THE TAMING OF THE SHREW',
                'ALL\'S WELL THAT ENDS WELL', 'MEASURE FOR MEASURE', 'TROILUS AND CRESSIDA',
                'TIMON OF ATHENS', 'KING JOHN', 'RICHARD II', 'HENRY IV, PART 1', 'HENRY IV, PART 2',
                'HENRY V', 'HENRY VI, PART 1', 'HENRY VI, PART 2', 'HENRY VI, PART 3', 'RICHARD III',
                'HENRY VIII', 'THE TWO NOBLE KINSMEN'
            ];
            
            // Look for the actual play title in the first 50 lines
            for (let i = 0; i < Math.min(50, lines.length); i++) {
                const line = lines[i].trim().toUpperCase();
                if (line && line.length > 0) {
                    // Skip common headers and stage directions
                    if (line.includes('DRAMATIS') || line.includes('ACT') || line.includes('SCENE') || 
                        line.includes('BY WILLIAM SHAKESPEARE') || line.includes('CHARACTERS') ||
                        line.startsWith('[') || line.startsWith('_') || line.length < 3) {
                        continue;
                    }
                    
                    // Check if this line matches a known Shakespeare title
                    for (const title of shakespeareTitles) {
                        if (line.includes(title) || title.includes(line)) {
                            return titleToProperCase(title);
                        }
                    }
                    
                    // Look for title patterns (all caps, reasonable length, no special characters)
                    if (line.match(/^[A-Z\s,]+$/) && line.length > 3 && line.length < 50) {
                        // Additional check: make sure it's not a character name
                        if (!line.includes('PRINCE') && !line.includes('KING') && !line.includes('QUEEN') &&
                            !line.includes('DUKE') && !line.includes('LORD') && !line.includes('LADY') &&
                            !line.includes('SIR') && !line.includes('CAPTAIN') && !line.includes('GENTLEMAN')) {
                            return titleToProperCase(line);
                        }
                    }
                }
            }
            
            // Fallback to filename
            return 'Unknown Play';
        }

        // Convert title to proper case
        function titleToProperCase(title) {
            // Convert to title case with proper handling of articles and prepositions
            const words = title.toLowerCase().split(' ');
            const articles = ['a', 'an', 'the', 'of', 'in', 'on', 'at', 'to', 'for', 'with', 'by'];
            
            return words.map((word, index) => {
                // Always capitalize first and last word
                if (index === 0 || index === words.length - 1) {
                    return word.charAt(0).toUpperCase() + word.slice(1);
                }
                // Capitalize articles and prepositions only if they're longer than 3 characters
                if (articles.includes(word) && word.length <= 3) {
                    return word;
                }
                // Capitalize all other words
                return word.charAt(0).toUpperCase() + word.slice(1);
            }).join(' ');
        }

        // Add play to library
        function addPlayToLibrary() {
            console.log('=== ADD PLAY BUTTON CLICKED ===');
            try {
                console.log('addPlayToLibrary function called');
                
                const playNameInput = document.getElementById('playNameInput');
                if (!playNameInput) {
                    console.error('playNameInput element not found');
                    return;
                }
                
                const playName = playNameInput.value.trim();
                console.log('Play name:', playName);
                console.log('Temp play data:', window.tempPlayData);
                
                if (!playName) {
                    return;
                }
                
                if (!window.tempPlayData) {
                    return;
                }
            
            // Parse the play text and add to library
            const fileName = window.tempPlayData.fileName;
            console.log('Calling parsePlayText with:', fileName, 'content length:', window.tempPlayData.content.length, 'playName:', playName);
            
            try {
                console.log('Starting parsePlayText...');
                if (window.tempPlayData.isXML) {
                    parsePlayXML(fileName, window.tempPlayData.content, playName);
                } else {
                    parsePlayText(fileName, window.tempPlayData.content, playName);
                }
                console.log('parsePlayText completed successfully');
                console.log('Plays object after parsing:', plays);
                console.log('Number of plays:', Object.keys(plays).length);
            } catch (parseError) {
                console.error('Error in parsePlayText:', parseError);
                alert('Error parsing play: ' + parseError.message);
                return;
            }
            
            // Simple synchronous approach
            try {
                console.log('Starting updatePlaySelector...');
                updatePlaySelector();
                console.log('updatePlaySelector completed');
            } catch (selectorError) {
                console.error('Error in updatePlaySelector:', selectorError);
                alert('Error updating play selector: ' + selectorError.message);
                return;
            }
            
            try {
                console.log('Starting updateLibraryPlays...');
                updateLibraryPlays();
                console.log('updateLibraryPlays completed');
            } catch (libraryError) {
                console.error('Error in updateLibraryPlays:', libraryError);
                alert('Error updating library: ' + libraryError.message);
                return;
            }
            
            // Complete the process
            completeAddPlayProcess(fileName, playName);
            
        } catch (error) {
            console.error('Error in addPlayToLibrary:', error);
            alert('Error adding play to library: ' + error.message);
        }
        }

        // Complete the add play process
        function completeAddPlayProcess(fileName, playName) {
            try {
                console.log('completeAddPlayProcess started');
                console.log('Completing add play process...');
                
                // Clear temporary data
                window.tempPlayData = null;
                
                // Hide the name input section
                const nameSection = document.getElementById('playNameSection');
                if (nameSection) {
                    nameSection.style.display = 'none';
                }
                
                // Show the upload section again
                const uploadSection = document.querySelector('.single-upload .file-upload');
                if (uploadSection) {
                    uploadSection.style.display = 'block';
                }
                
                // Clear the file input
                const fileInput = document.getElementById('playFile');
                if (fileInput) {
                    fileInput.value = '';
                }
                
                // Show success message
                const successMsg = document.getElementById('uploadSuccess');
                if (successMsg) {
                    successMsg.style.display = 'block';
                    successMsg.textContent = `✅ "${playName}" has been added to your library!`;
                }
                
                // Auto-select the new play
                const selector = document.getElementById('playSelector');
                if (selector) {
                    selector.value = fileName;
                }
                
                // Load the play (use fileName as the key)
                console.log('Loading play with fileName key:', fileName);
                console.log('Available play keys:', Object.keys(plays));
                console.log('Play object for fileName:', plays[fileName]);
                
                // Temporarily disable loadPlay to test if it's causing the hang
                console.log('Skipping loadPlay for now to test completion');
                // loadPlay(fileName);
                
                console.log('Add play process completed successfully!');
                // Success message is already shown above, keep settings open
            } catch (error) {
                console.error('Error completing add play process:', error);
                alert('Error completing process: ' + error.message);
            }
        }

        // Cancel upload and reset to initial state
        function cancelUpload() {
            // Hide the name input section
            document.getElementById('playNameSection').style.display = 'none';
            
            // Show the upload section again
            const uploadSection = document.querySelector('.single-upload .file-upload');
            if (uploadSection) {
                uploadSection.style.display = 'block';
            }
            
            // Clear the file input
            const fileInput = document.getElementById('playFile');
            if (fileInput) {
                fileInput.value = '';
            }
            
            // Clear temporary data
            window.tempPlayData = null;
            
            // Hide any messages
            document.getElementById('uploadSuccess').style.display = 'none';
            document.getElementById('uploadError').style.display = 'none';
        }

        // File upload handling
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Hide any previous messages
            document.getElementById('uploadSuccess').style.display = 'none';
            document.getElementById('uploadError').style.display = 'none';

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    const isXML = file.name.toLowerCase().endsWith('.xml');
                    const fileName = isXML ? file.name.replace('.xml', '') : file.name.replace('.txt', '');
                    
                    console.log('=== FILE UPLOAD DEBUG ===');
                    console.log('File name:', file.name);
                    console.log('File type:', isXML ? 'XML' : 'TXT');
                    console.log('File size:', file.size, 'bytes');
                    console.log('Content length:', content.length, 'characters');
                    console.log('First 500 characters:', content.substring(0, 500));
                    console.log('Lines in file:', content.split('\n').length);
                    console.log('=== END DEBUG ===');
                    
                    // Parse the play to detect the title (but don't add to library yet)
                    const detectedPlayName = isXML ? detectPlayTitleFromXML(content) : detectPlayTitle(content);
                    
                    // Show the name input section
                    document.getElementById('playNameSection').style.display = 'block';
                    
                    // Hide the upload section to avoid confusion
                    const uploadSection = document.querySelector('.single-upload .file-upload');
                    if (uploadSection) {
                        uploadSection.style.display = 'none';
                    }
                    
                    // Populate the name input with the detected play name (in proper case)
                    document.getElementById('playNameInput').value = detectedPlayName;
                    
                    // Store the parsed content temporarily for later use
                    window.tempPlayData = {
                        fileName: fileName,
                        content: content,
                        detectedName: detectedPlayName,
                        isXML: isXML
                    };
                    
                    // Show success message
                    document.getElementById('uploadSuccess').style.display = 'block';
                    document.getElementById('uploadSuccess').textContent = `✅ ${isXML ? 'TEISimple XML' : 'Text'} file uploaded successfully! Review the play name and click "Add Play" to add it to your library.`;
                    
                } catch (error) {
                    console.error('Error processing file:', error);
                    document.getElementById('uploadError').style.display = 'block';
                }
            };
            
            reader.onerror = function() {
                document.getElementById('uploadError').style.display = 'block';
            };
            
            reader.readAsText(file);
        }

        // Bulk upload handling
        function handleBulkUpload(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;

            // Hide any previous messages
            document.getElementById('uploadSuccess').style.display = 'none';
            document.getElementById('uploadError').style.display = 'none';

            // Store bulk upload data
            window.bulkUploadData = [];
            let processedCount = 0;

            Array.from(files).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const content = e.target.result;
                        const isXML = file.name.toLowerCase().endsWith('.xml');
                        const fileName = isXML ? file.name.replace('.xml', '') : file.name.replace('.txt', '');
                        const detectedName = isXML ? detectPlayTitleFromXML(content) : detectPlayTitle(content);
                        
                        // Store data for bulk processing
                        window.bulkUploadData.push({
                            fileName: fileName,
                            content: content,
                            detectedName: detectedName,
                            originalName: fileName,
                            isXML: isXML
                        });
                        
                        processedCount++;
                        
                        // When all files are processed, show rename interface
                        if (processedCount === files.length) {
                            showBulkRenameInterface();
                        }
                        
                    } catch (error) {
                        console.error('Error processing file:', file.name, error);
                        processedCount++;
                        
                        if (processedCount === files.length) {
                            showBulkRenameInterface();
                        }
                    }
                };
                
                reader.onerror = function() {
                    console.error('Error reading file:', file.name);
                    processedCount++;
                    
                    if (processedCount === files.length) {
                        showBulkRenameInterface();
                    }
                };
                
                reader.readAsText(file);
            });
        }

        // Show bulk rename interface
        function showBulkRenameInterface() {
            const bulkSection = document.querySelector('.bulk-upload');
            
            // Create rename interface
            let renameHTML = '<div class="bulk-rename-section">';
            renameHTML += '<h4>Review and Rename Plays</h4>';
            renameHTML += '<div class="bulk-rename-list">';
            
            window.bulkUploadData.forEach((play, index) => {
                renameHTML += `
                    <div class="bulk-rename-item">
                        <label for="bulkName${index}">Play ${index + 1}:</label>
                        <input type="text" id="bulkName${index}" value="${play.detectedName}" class="bulk-name-input">
                        <span class="original-filename">(from: ${play.originalName})</span>
                    </div>
                `;
            });
            
            renameHTML += '</div>';
            renameHTML += '<button onclick="processBulkUpload()" class="add-btn">Add All Plays</button>';
            renameHTML += '</div>';
            
            // Replace bulk upload section content
            bulkSection.innerHTML = renameHTML;
        }

        // Process bulk upload with custom names
        function processBulkUpload() {
            let successCount = 0;
            let errorCount = 0;

            window.bulkUploadData.forEach((play, index) => {
                try {
                    const customName = document.getElementById(`bulkName${index}`).value.trim();
                    const playName = customName || play.detectedName;
                    
                    if (play.isXML) {
                        parsePlayXML(play.fileName, play.content, playName);
                    } else {
                        parsePlayText(play.fileName, play.content, playName);
                    }
                    successCount++;
                } catch (error) {
                    console.error('Error processing play:', play.fileName, error);
                    errorCount++;
                }
            });

            // Update UI
            updatePlaySelector();
            updateLibraryPlays();
            
            // Show success message (keep settings open)
            if (successCount > 0) {
                const successMsg = document.getElementById('uploadSuccess');
                successMsg.style.display = 'block';
                successMsg.textContent = `✅ Successfully uploaded ${successCount} play(s)!`;
            }
            
            if (errorCount > 0) {
                const errorMsg = document.getElementById('uploadError');
                errorMsg.style.display = 'block';
                errorMsg.textContent = `❌ ${errorCount} play(s) failed to upload.`;
            }
            
            // Clear bulk upload data
            window.bulkUploadData = null;
            
            // Reset bulk upload section
            resetBulkUploadSection();
        }

        // Reset bulk upload section to original state
        function resetBulkUploadSection() {
            const bulkSection = document.querySelector('.bulk-upload');
            bulkSection.innerHTML = `
                <h4>Bulk Upload Multiple Plays</h4>
                <div class="file-upload">
                    <input type="file" id="bulkPlayFiles" accept=".xml,.txt" multiple onchange="handleBulkUpload(event)">
                    <label for="bulkPlayFiles">Choose multiple play files (.xml or .txt)</label>
                    <div class="upload-instructions">
                        Select multiple TEISimple XML files (with MorphAdorner annotations) or .txt files to upload several plays at once with enhanced linguistic analysis.
                    </div>
                </div>
            `;
        }

        // Parse play text into structured data
        function parsePlayText(fileName, content, customPlayName = null) {
            console.log('parsePlayText started');
                            console.log('parsePlayText started');
            
            const lines = content.split('\n');
            console.log('Content split into', lines.length, 'lines');
            
            // Use custom play name if provided, otherwise extract from content
            let actualPlayName = customPlayName || fileName;
            
            const play = {
                name: actualPlayName,
                originalFileName: fileName,
                characters: [],
                acts: {},
                scenes: {}
            };

            let currentAct = '';
            let currentScene = '';
            let inDramatisPersonae = false;
            let inScene = false;
            let sceneContent = [];

            console.log('Starting to parse play:', fileName);
            console.log('Total lines:', lines.length);
            console.log('Starting parsing loop with ' + lines.length + ' lines');

            for (let i = 0; i < lines.length; i++) {
                // Add progress indicator every 1000 lines
                if (i % 1000 === 0) {
                    console.log('Processing line', i, 'of', lines.length);
                }
                const line = lines[i].trim();
                
                // Skip empty lines
                if (!line) continue;
                
                // Check for Dramatis Personae section
                if (line.toLowerCase().includes('dramatis personae') || 
                    line.toLowerCase().includes('characters in the play') ||
                    line.toLowerCase().includes('persons represented') ||
                    line.toLowerCase().includes('dramatis personæ')) {
                    console.log('Found Dramatis Personae at line', i, ':', line);
                    inDramatisPersonae = true;
                    inScene = false;
                    continue;
                }

                // Check for Act headers (much more flexible matching)
                if (line.match(/^ACT\s+[IVX]+/i) || 
                    line.match(/^ACT\s+[0-9]+/i) ||
                    line.match(/^ACT\s+[A-Z]+/i) ||
                    line.match(/^THE\s+FIRST\s+PART\s+OF\s+KING\s+HENRY\s+THE\s+FOURTH/i) ||
                    line.match(/^THE\s+SECOND\s+PART\s+OF\s+KING\s+HENRY\s+THE\s+FOURTH/i) ||
                    line.match(/^KING\s+HENRY\s+THE\s+FOURTH/i)) {
                    console.log('Found Act at line', i, ':', line);
                    inDramatisPersonae = false;
                    inScene = false;
                    currentAct = line;
                    play.acts[currentAct] = [];
                    continue;
                }

                // Check for Scene headers (much more flexible matching)
                if (line.match(/^SCENE\s+[IVX]+/i) || 
                    line.match(/^SCENE\s+[0-9]+/i) ||
                    line.match(/^SCENE\s+[A-Z]+/i) ||
                    line.match(/^SCENE\s+[IVX]+\./i) ||
                    line.match(/^SCENE\s+[0-9]+\./i)) {
                    console.log('Found Scene at line', i, ':', line);
                    inScene = true;
                    currentScene = `${currentAct} - ${line}`;
                    play.scenes[currentScene] = [];
                    if (currentAct) {
                        play.acts[currentAct].push(currentScene);
                    }
                    sceneContent = [];
                    continue;
                }

                // Collect characters from Dramatis Personae
                if (inDramatisPersonae && line && !line.startsWith('[') && !line.startsWith('_') && line.length > 0) {
                    const character = line.split('.')[0].trim();
                    if (character && character.length > 0 && character.length < 50 && !play.characters.includes(character)) {
                        play.characters.push(character);
                        console.log('Found character:', character);
                    }
                }

                // Collect scene content
                if (inScene && currentScene && line) {
                    play.scenes[currentScene].push(line);
                }
            }

            // Clean up empty scenes and group dialogue by speaker
            Object.keys(play.scenes).forEach(sceneKey => {
                if (play.scenes[sceneKey].length === 0) {
                    delete play.scenes[sceneKey];
                    // Remove from acts too
                    Object.keys(play.acts).forEach(actKey => {
                        play.acts[actKey] = play.acts[actKey].filter(scene => scene !== sceneKey);
                    });
                } else {
                    // Group dialogue by speaker
                    play.scenes[sceneKey] = groupDialogueBySpeaker(play.scenes[sceneKey]);
                }
            });

            // If no acts found, try alternative parsing
            if (Object.keys(play.acts).length === 0) {
                console.log('No acts found with standard parsing, trying alternative method...');
                parsePlayTextAlternative(fileName, content, play);
            }

            plays[fileName] = play;
            console.log('Final parsed play:', fileName, play);
            console.log('Acts found:', Object.keys(play.acts));
            console.log('Scenes found:', Object.keys(play.scenes));
            console.log('Parsing completed successfully');
            
            // Set as current play if it's the first one
            if (Object.keys(plays).length === 1) {
                currentPlay = fileName;
                try {
                    loadPlay(currentPlay);
                } catch (loadError) {
                    console.error('Error in loadPlay:', loadError);
                }
            }
        }

        // Group dialogue lines by speaker to avoid repeating speaker names
        function groupDialogueBySpeaker(lines) {
            const groupedLines = [];
            let currentSpeaker = '';
            let currentDialogue = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                // Check if this line is a speaker name (all caps, short, no punctuation)
                const isSpeakerName = /^[A-Z\s]+$/.test(line) && line.length < 30 && !line.includes('.') && !line.includes(',');
                
                if (isSpeakerName) {
                    // If we have accumulated dialogue from previous speaker, add it
                    if (currentSpeaker && currentDialogue.length > 0) {
                        groupedLines.push(`${currentSpeaker}\n${currentDialogue.join('\n')}`);
                    }
                    // Start new speaker
                    currentSpeaker = line;
                    currentDialogue = [];
                } else {
                    // This is dialogue, add to current speaker's dialogue
                    currentDialogue.push(line);
                }
            }
            
            // Add the last speaker's dialogue
            if (currentSpeaker && currentDialogue.length > 0) {
                groupedLines.push(`${currentSpeaker}\n${currentDialogue.join('\n')}`);
            }
            
            return groupedLines;
        }

        // Alternative parsing method for plays that don't follow standard format
        function parsePlayTextAlternative(fileName, content, play) {
            const lines = content.split('\n');
            let currentAct = '';
            let currentScene = '';
            let inScene = false;

            console.log('Trying alternative parsing for:', fileName);

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                // Look for any line that might be an act (contains "ACT" or roman numerals)
                if (line.match(/ACT/i) || line.match(/^[IVX]+\./i) || line.match(/^[IVX]+\s*$/i)) {
                    console.log('Alternative: Found potential act at line', i, ':', line);
                    currentAct = line;
                    play.acts[currentAct] = [];
                    inScene = false;
                    continue;
                }

                // Look for any line that might be a scene (contains "SCENE" or numbers)
                if (line.match(/SCENE/i) || line.match(/^[0-9]+\./i) || line.match(/^[IVX]+\./i)) {
                    console.log('Alternative: Found potential scene at line', i, ':', line);
                    currentScene = `${currentAct} - ${line}`;
                    play.scenes[currentScene] = [];
                    if (currentAct) {
                        play.acts[currentAct].push(currentScene);
                    }
                    inScene = true;
                    continue;
                }

                // Collect scene content
                if (inScene && currentScene && line) {
                    play.scenes[currentScene].push(line);
                }
            }
            
            // Group dialogue by speaker for alternative parsing too
            Object.keys(play.scenes).forEach(sceneKey => {
                if (play.scenes[sceneKey].length > 0) {
                    play.scenes[sceneKey] = groupDialogueBySpeaker(play.scenes[sceneKey]);
                }
            });
        }

        // XML parsing functions for TEISimple with MorphAdorner annotations
        function detectPlayTitleFromXML(content) {
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(content, 'text/xml');
                
                // Check for parsing errors
                const parseError = xmlDoc.getElementsByTagName('parsererror');
                if (parseError.length > 0) {
                    throw new Error('Invalid XML format');
                }
                
                // Try to find title in TEI header
                const titleStmt = xmlDoc.querySelector('titleStmt title');
                if (titleStmt && titleStmt.textContent.trim()) {
                    return titleStmt.textContent.trim();
                }
                
                // Try alternative title locations
                const title = xmlDoc.querySelector('title');
                if (title && title.textContent.trim()) {
                    return title.textContent.trim();
                }
                
                // Try to extract from filename or fallback
                return 'Shakespeare Play';
                
            } catch (error) {
                console.error('Error parsing XML title:', error);
                return 'Shakespeare Play';
            }
        }

        function parsePlayXML(fileName, content, customPlayName = null) {
            console.log('parsePlayXML started for:', fileName);
            
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(content, 'text/xml');
                
                // Check for parsing errors
                const parseError = xmlDoc.getElementsByTagName('parsererror');
                if (parseError.length > 0) {
                    throw new Error('Invalid XML format');
                }
                
                // Use custom play name if provided, otherwise extract from XML
                let actualPlayName = customPlayName || detectPlayTitleFromXML(content) || fileName;
                
                const play = {
                    name: actualPlayName,
                    originalFileName: fileName,
                    characters: [],
                    acts: {},
                    scenes: {},
                    isXML: true,
                    morphAdornerData: {} // Store MorphAdorner annotations
                };

                // Extract characters from TEI header
                const castList = xmlDoc.querySelector('castList');
                if (castList) {
                    const castItems = castList.querySelectorAll('castItem');
                    castItems.forEach(item => {
                        const role = item.querySelector('role');
                        const actor = item.querySelector('actor');
                        if (role) {
                            const characterName = role.textContent.trim();
                            if (characterName && !play.characters.includes(characterName)) {
                                play.characters.push(characterName);
                            }
                        }
                    });
                }

                // Parse acts and scenes
                const acts = xmlDoc.querySelectorAll('div[type="act"]');
                acts.forEach((act, actIndex) => {
                    const actNum = actIndex + 1;
                    const actName = `ACT ${actNum}`;
                    play.acts[actName] = [];
                    
                    const scenes = act.querySelectorAll('div[type="scene"]');
                    scenes.forEach((scene, sceneIndex) => {
                        const sceneNum = sceneIndex + 1;
                        const sceneName = `${actName} - SCENE ${sceneNum}`;
                        play.scenes[sceneName] = [];
                        play.acts[actName].push(sceneName);
                        
                        // Extract scene content with MorphAdorner annotations
                        const sceneContent = extractSceneContentFromXML(scene, play);
                        play.scenes[sceneName] = sceneContent;
                    });
                });

                // Add to plays object
                plays[fileName] = play;
                console.log('XML parsing completed for:', fileName);
                console.log('Play structure:', play);
                
            } catch (error) {
                console.error('Error parsing XML:', error);
                throw error;
            }
        }

        function extractSceneContentFromXML(sceneElement, play) {
            const sceneContent = [];
            
            // Process all child elements
            const children = sceneElement.children;
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                
                if (child.tagName === 'sp') {
                    // Speech element
                    const speaker = child.querySelector('speaker');
                    const speakerName = speaker ? speaker.textContent.trim() : 'UNKNOWN';
                    
                    // Extract lines with MorphAdorner annotations
                    const lines = child.querySelectorAll('l');
                    lines.forEach(line => {
                        const lineText = extractLineWithAnnotations(line);
                        if (lineText) {
                            sceneContent.push(`${speakerName.toUpperCase()}`);
                            sceneContent.push(lineText);
                        }
                    });
                    
                } else if (child.tagName === 'stage') {
                    // Stage direction
                    const stageText = `[${child.textContent.trim()}]`;
                    sceneContent.push(stageText);
                    
                } else if (child.tagName === 'l') {
                    // Direct line (no speaker)
                    const lineText = extractLineWithAnnotations(child);
                    if (lineText) {
                        sceneContent.push(lineText);
                    }
                }
            }
            
            return sceneContent;
        }

        function extractLineWithAnnotations(lineElement) {
            // Extract text with MorphAdorner part-of-speech annotations
            let lineText = '';
            
            // Process words with annotations
            const words = lineElement.querySelectorAll('w');
            if (words.length > 0) {
                words.forEach(word => {
                    const wordText = word.textContent.trim();
                    const pos = word.getAttribute('pos'); // Part of speech
                    const lemma = word.getAttribute('lemma'); // Lemma form
                    
                    // Add word with annotations if available
                    if (pos && lemma) {
                        lineText += `${wordText} (${pos}/${lemma}) `;
                    } else {
                        lineText += wordText + ' ';
                    }
                });
            } else {
                // Fallback to plain text
                lineText = lineElement.textContent.trim();
            }
            
            return lineText.trim();
        }

        // Update play selector dropdown
        function updatePlaySelector() {
            console.log('updatePlaySelector called');
            console.log('plays object:', plays);
            console.log('Number of plays:', Object.keys(plays).length);
            
            const selector = document.getElementById('playSelector');
            if (!selector) {
                console.error('playSelector element not found');
                return;
            }
            
            const currentValue = selector.value; // Remember current selection
            console.log('Current selector value:', currentValue);
            
            selector.innerHTML = '<option value="" disabled selected>Choose a Play</option>';
            
            const playKeys = Object.keys(plays);
            console.log('Total plays to add:', playKeys.length);
            
            // Sort plays alphabetically by name
            const sortedPlays = playKeys.sort((a, b) => {
                return plays[a].name.localeCompare(plays[b].name);
            });
            
            // Simple synchronous approach
            sortedPlays.forEach(playName => {
                console.log('Adding play to selector:', playName, 'with name:', plays[playName].name);
                const option = document.createElement('option');
                option.value = playName;
                option.textContent = plays[playName].name;
                selector.appendChild(option);
            });
            
            // Restore selection if it was valid
            if (currentValue && plays[currentValue]) {
                selector.value = currentValue;
                console.log('Restored selection to:', currentValue);
            }
            
            console.log('updatePlaySelector completed');
        }

        // Update library plays list
        function updateLibraryPlays() {
            console.log('updateLibraryPlays called');
            console.log('plays object:', plays);
            console.log('Number of plays:', Object.keys(plays).length);
            
            const container = document.getElementById('libraryPlays');
            if (!container) {
                console.error('libraryPlays element not found');
                return;
            }
            
            container.innerHTML = '';
            
            if (Object.keys(plays).length === 0) {
                container.innerHTML = '<p style="color: #6c757d; font-style: italic;">No plays in library yet.</p>';
                console.log('No plays to display');
                return;
            }
            
            // Sort plays alphabetically by name
            const sortedPlays = Object.keys(plays).sort((a, b) => {
                return plays[a].name.localeCompare(plays[b].name);
            });
            
            sortedPlays.forEach(playName => {
                const play = plays[playName];
                const playItem = document.createElement('div');
                playItem.className = 'library-item';
                
                const actCount = Object.keys(play.acts).length;
                const sceneCount = Object.keys(play.scenes).length;
                const characterCount = play.characters.length;
                
                playItem.innerHTML = `
                    <div>
                        <div class="library-name">${play.name}</div>
                        <div class="play-info">
                            ${actCount} act(s) • ${sceneCount} scene(s) • ${characterCount} character(s)
                        </div>
                    </div>
                    <button class="delete-play" onclick="deletePlay('${playName}')">Delete</button>
                `;
                container.appendChild(playItem);
            });
        }

        // Delete a play from library
        function deletePlay(playName) {
            if (confirm(`Are you sure you want to delete "${plays[playName].name}" from your library?`)) {
                delete plays[playName];
                updatePlaySelector();
                updateLibraryPlays();
                
                if (currentPlay === playName) {
                    currentPlay = '';
                    loadPlay('');
                }
                
                // Show success message
                document.getElementById('uploadSuccess').style.display = 'block';
                document.getElementById('uploadSuccess').textContent = `✅ Play deleted from library.`;
            }
        }

        // Load selected play from dropdown
        function loadSelectedPlay() {
            const selector = document.getElementById('playSelector');
            const selectedPlay = selector.value;
            if (selectedPlay) {
                loadPlay(selectedPlay);
            }
        }

        // Load a play
        function loadPlay(playName) {
            console.log('loadPlay called with:', playName);
            console.log('plays object keys:', Object.keys(plays));
            console.log('plays[playName]:', plays[playName]);
            
            if (!playName || !plays[playName]) {
                console.log('Play not found or invalid:', playName);
                document.getElementById('playText').innerHTML = `
                    <div class="scene-title">Welcome to Shakespeare Digital Variorum</div>
                    <div class="scene-separator"></div>
                    <p>Please upload a play text file in Settings to begin analyzing Shakespeare's works.</p>
                `;
                document.getElementById('navigationList').innerHTML = '';
                return;
            }

            const play = plays[playName];
            currentPlay = playName;
            
            console.log('Loading play:', playName, 'with acts:', Object.keys(play.acts));
            
            // Update navigation
            updateNavigation(play);
            
            // Load first scene automatically
            const firstAct = Object.keys(play.acts)[0];
            if (firstAct && play.acts[firstAct] && play.acts[firstAct].length > 0) {
                const firstScene = play.acts[firstAct][0];
                console.log('Loading first scene:', firstScene);
                loadScene(firstScene);
            } else {
                console.log('No scenes found, showing welcome message');
                // If no scenes found, show welcome message
                document.getElementById('playText').innerHTML = `
                    <div class="scene-title">${playName}</div>
                    <div class="scene-separator"></div>
                    <p>Play loaded successfully. Use the navigation to explore acts and scenes.</p>
                    <p><em>Debug: Found ${Object.keys(play.acts).length} acts</em></p>
                `;
            }
        }

        // Update navigation list
        function updateNavigation(play) {
            const navList = document.getElementById('navigationList');
            navList.innerHTML = '';
            
            console.log('Updating navigation for play:', play.name, play);
            
            // Add Dramatis Personae
            if (play.characters.length > 0) {
                const dramatisItem = document.createElement('li');
                dramatisItem.innerHTML = '<a href="#" onclick="showDramatisPersonae()">Dramatis Personae</a>';
                navList.appendChild(dramatisItem);
            }
            
            // Add Acts and Scenes
            Object.keys(play.acts).forEach(actName => {
                const actItem = document.createElement('li');
                actItem.innerHTML = `<a href="#" onclick="loadFirstSceneOfAct('${actName}')">${actName}</a>`;
                navList.appendChild(actItem);
                
                if (play.acts[actName] && play.acts[actName].length > 0) {
                    play.acts[actName].forEach(sceneName => {
                        const sceneItem = document.createElement('li');
                        sceneItem.className = 'sub-item';
                        sceneItem.innerHTML = `<a href="#" onclick="loadScene('${sceneName}')" data-scene="${sceneName}">${sceneName.split(' - ')[1]}</a>`;
                        navList.appendChild(sceneItem);
                    });
                }
            });
            
            // Set initial active state if no scene is currently selected
            if (!currentScene && Object.keys(play.acts).length > 0) {
                const firstAct = Object.keys(play.acts)[0];
                if (play.acts[firstAct] && play.acts[firstAct].length > 0) {
                    const firstScene = play.acts[firstAct][0];
                    updateActiveNavigation(firstScene);
                }
            }
        }

        // Load the first scene of a specific act
        function loadFirstSceneOfAct(actName) {
            if (!currentPlay || !plays[currentPlay] || !plays[currentPlay].acts[actName]) {
                console.log('Act not found:', actName, 'in play:', currentPlay);
                return;
            }
            
            const scenes = plays[currentPlay].acts[actName];
            if (scenes && scenes.length > 0) {
                const firstScene = scenes[0];
                loadScene(firstScene);
            }
        }

        // Load a specific scene
        function loadScene(sceneName) {
            if (!currentPlay || !plays[currentPlay] || !plays[currentPlay].scenes[sceneName]) {
                console.log('Scene not found:', sceneName, 'in play:', currentPlay);
                alert('Scene not found: ' + sceneName);
                return;
            }

            currentScene = sceneName;
            const sceneContent = plays[currentPlay].scenes[sceneName];
            
            console.log('Loading scene:', sceneName, 'with content length:', sceneContent.length);
            
            // Update active navigation
            updateActiveNavigation(sceneName);
            
            // Display scene content
            const playText = document.getElementById('playText');
            const formattedContent = formatSceneContent(sceneContent);
            playText.innerHTML = `
                <div class="scene-title">${sceneName}</div>
                <div class="scene-separator"></div>
                ${formattedContent}
            `;
        }

        // Format scene content for display
        function formatSceneContent(sceneContent) {
            let html = '';
            
            if (!sceneContent || sceneContent.length === 0) {
                return '<p><em>No content found for this scene.</em></p>';
            }
            
            // Process each grouped dialogue block
            sceneContent.forEach(block => {
                const lines = block.split('\n');
                if (lines.length === 0) return;
                
                const speaker = lines[0].trim();
                const dialogueLines = lines.slice(1).filter(line => line.trim() !== '');
                
                if (dialogueLines.length > 0) {
                    html += `<div class="dialogue">`;
                    html += `<div class="character-name">${speaker}</div>`;
                    html += `<div class="dialogue-text">${dialogueLines.join('<br>')}</div>`;
                    html += `</div>`;
                }
            });
            
            return html || '<p><em>Scene content could not be formatted.</em></p>';
        }
                if (trimmedLine.startsWith('[') && trimmedLine.endsWith(']')) {
                    console.log('Found complete stage direction:', trimmedLine);
                    if (inDialogue) {
                        // Close current dialogue block
                        if (currentDialogueText) {
                            html += `<div class="dialogue-text">${currentDialogueText}</div>`;
                            currentDialogueText = '';
                        }
                        html += '</div></div>';
                        inDialogue = false;
                    }
                    html += `<div class="stage-direction"><em>${trimmedLine}</em></div>`;
                    i++;
                    continue;
                }
                
                // Check for start of multi-line stage direction
                if (trimmedLine.startsWith('[') && !trimmedLine.endsWith(']')) {
                    console.log('Found start of multi-line stage direction:', trimmedLine);
                    if (inDialogue) {
                        // Close current dialogue block
                        if (currentDialogueText) {
                            html += `<div class="dialogue-text">${currentDialogueText}</div>`;
                            currentDialogueText = '';
                        }
                        html += '</div></div>';
                        inDialogue = false;
                    }
                    inStageDirection = true;
                    stageDirectionText = trimmedLine;
                    i++;
                    continue;
                }
                
                // Check for continuation of multi-line stage direction
                if (inStageDirection) {
                    stageDirectionText += ' ' + trimmedLine;
                    console.log('Continuing stage direction:', stageDirectionText);
                    
                    // Check if stage direction ends
                    if (trimmedLine.endsWith(']')) {
                        console.log('Found end of multi-line stage direction:', stageDirectionText);
                        html += `<div class="stage-direction"><em>${stageDirectionText}</em></div>`;
                        inStageDirection = false;
                        stageDirectionText = '';
                    }
                    i++;
                    continue;
                }
                
                // Check for all-caps speaker names (simplified detection)
                if (trimmedLine.match(/^[A-Z\s,]+$/) && trimmedLine.length > 2 && trimmedLine.length < 50) {
                    // Avoid stage directions
                    const stageDirections = ['ACT', 'SCENE', 'ENTER', 'EXIT', 'EXEUNT', 'WITHIN', 'ABOVE', 'BELOW', 'CURTAIN'];
                    const upperLine = trimmedLine.toUpperCase();
                    
                    if (!stageDirections.some(word => upperLine.includes(word))) {
                        console.log('Found speaker name:', trimmedLine);
                        if (inDialogue) {
                            // Close current dialogue block
                            if (currentDialogueText) {
                                html += `<div class="dialogue-text">${currentDialogueText}</div>`;
                                currentDialogueText = '';
                            }
                            html += '</div></div>';
                            inDialogue = false;
                        }
                        html += `<div class="dialogue" style="margin-top: 20px;"><div class="character-name">${trimmedLine}</div>`;
                        inDialogue = true;
                        i++;
                        continue;
                    }
                }
                
                // Check for inline speakers (all caps followed by dialogue)
                const inlineSpeakerMatch = trimmedLine.match(/^([A-Z][A-Z\s,]*[A-Z])\s+(.+)$/);
                if (inlineSpeakerMatch) {
                    let speakerName = inlineSpeakerMatch[1].trim();
                    let dialogue = inlineSpeakerMatch[2].trim();
                    
                    // Clean up speaker name - remove trailing single letters that are likely part of dialogue
                    const speakerWords = speakerName.split(/\s+/);
                    const lastWord = speakerWords[speakerWords.length - 1];
                    
                    // If the last word is a single letter (like "I", "A", "O"), move it to dialogue
                    if (lastWord.length === 1 && /^[A-Z]$/.test(lastWord)) {
                        speakerName = speakerWords.slice(0, -1).join(' ');
                        dialogue = lastWord + ' ' + dialogue;
                        console.log('Moved single letter from speaker to dialogue:', lastWord);
                    }
                    
                    // Check if speaker name looks like a real speaker (at least 2 characters)
                    if (speakerName.match(/^[A-Z][A-Z\s,]*[A-Z]$/) && speakerName.length >= 2) {
                        const stageDirections = ['ACT', 'SCENE', 'ENTER', 'EXIT', 'EXEUNT', 'WITHIN', 'ABOVE', 'BELOW', 'CURTAIN'];
                        const upperSpeaker = speakerName.toUpperCase();
                        
                        if (!stageDirections.some(word => upperSpeaker.includes(word))) {
                            console.log('Found inline speaker:', speakerName, 'with dialogue:', dialogue);
                            if (inDialogue) {
                                // Close current dialogue block
                                if (currentDialogueText) {
                                    html += `<div class="dialogue-text">${currentDialogueText}</div>`;
                                    currentDialogueText = '';
                                }
                                html += '</div></div>';
                                inDialogue = false;
                            }
                            const formattedDialogue = formatBracketedText(dialogue);
                            html += `<div class="dialogue" style="margin-top: 20px;"><div class="character-name">${speakerName}</div><div class="dialogue-text"><span class="line">${formattedDialogue}</span></div></div>`;
                            inDialogue = false;
                            i++;
                            continue;
                        }
                    }
                }
                
                // Regular dialogue or unattributed text
                let formattedLine = formatBracketedText(trimmedLine);
                
                // Debug: log the line to see what we're processing
                console.log('Processing dialogue line:', trimmedLine, 'formatted:', formattedLine, 'original line:', line);
                
                if (inDialogue) {
                    // Accumulate dialogue text with line spans
                    if (currentDialogueText) {
                        // Add line span to preserve original structure
                        if (formattedLine.trim()) {
                            currentDialogueText += '<span class="line">' + formattedLine + '</span>';
                        }
                    } else {
                        currentDialogueText = '<span class="line">' + formattedLine + '</span>';
                    }
                } else {
                    html += `<div class="dialogue-text"><span class="line">${formattedLine}</span></div>`;
                }
                
                i++;
            }
            
            return html || '<p><em>Scene content could not be formatted.</em></p>';
        }

        // Analyze the text to identify speaker patterns
        function analyzeSpeakerPatterns(sceneContent) {
            const patterns = {
                allCaps: [],
                boldText: [],
                numberedSpeakers: [],
                titleSpeakers: [],
                potentialSpeakers: []
            };
            
            sceneContent.forEach((line, index) => {
                const trimmedLine = line.trim();
                if (trimmedLine === '') return;
                
                // Check for bold text patterns
                if (trimmedLine.startsWith('**') && trimmedLine.endsWith('**')) {
                    patterns.boldText.push({ line: trimmedLine, index });
                }
                
                // Check for all caps patterns
                if (trimmedLine.match(/^[A-Z\s]+$/) && trimmedLine.length > 2 && trimmedLine.length < 50) {
                    patterns.allCaps.push({ line: trimmedLine, index });
                }
                
                // Check for numbered speakers
                if (trimmedLine.match(/^(FIRST|SECOND|THIRD|FOURTH|FIFTH|SIXTH|SEVENTH|EIGHTH|NINTH|TENTH)\s+[A-Z\s]+$/)) {
                    patterns.numberedSpeakers.push({ line: trimmedLine, index });
                }
                
                // Check for title-based speakers
                const titleMatch = trimmedLine.match(/^[A-Z\s]+(KING|QUEEN|PRINCE|PRINCESS|DUKE|DUCHESS|LORD|LADY|SIR|MADAM|MISTRESS|CAPTAIN|GENTLEMAN|GENTLEWOMAN|SERVANT|MESSENGER|SOLDIER|GUARD|PRIEST|FRIAR|NURSE|ATTENDANT|OFFICER|CLOWN|FOOL|JESTER|HERALD|AMBASSADOR|SENATOR|COUNCILLOR|JUDGE|LAWYER|DOCTOR|APOTHECARY|MERCHANT|TRADER|ARTISAN|PEASANT|CITIZEN|COMMONER|VILLAGER|TOWNSMAN|COUNTRYMAN|SHEPHERD|HUNTER|FISHERMAN|FARMER|GARDENER|COOK|BUTLER|MAID|PAGE|BOY|GIRL|CHILD|MAN|WOMAN|PERSON|FRIEND|ENEMY|STRANGER|VISITOR|GUEST|HOST|HOSTESS|INNKEEPER|TAVERN|SHOPKEEPER|CRAFTSMAN|SCHOLAR|STUDENT|TEACHER|MASTER|SERVANT|SLAVE|PRISONER|EXILE|REFUGEE|WANDERER|TRAVELER|PILGRIM|HERMIT|WITCH|WIZARD|SORCERER|MAGICIAN|PROPHET|ORACLE|SEER|FORTUNE|TELLER|BEGGAR|THIEF|ROBBER|PIRATE|MURDERER|ASSASSIN|SPY|TRAITOR|REBEL|CONSPIRATOR|REVOLUTIONARY|PATRIOT|LOYALIST|ROYALIST|REPUBLICAN|DEMOCRAT|LIBERAL|CONSERVATIVE|RADICAL|MODERATE|EXTREMIST|FANATIC|ZEALOT|HERETIC|BLASPHEMER|SINNER|SAINT|MARTYR|HERO|VILLAIN|PROTAGONIST|ANTAGONIST|SUPPORTING|CHARACTER|EXTRA|WALK|ON|CROWD|CHORUS|NARRATOR|STORYTELLER|COMMENTATOR|ANNOUNCER|CALLER|BARKER|CUSTOMER|CLIENT|PATRON|REGULAR|FAMILIAR|UNKNOWN|MYSTERIOUS|HIDDEN|SECRET|PRIVATE|PUBLIC|OFFICIAL|UNOFFICIAL|FORMAL|INFORMAL|CASUAL|CEREMONIAL|RITUAL|TRADITIONAL|MODERN|CONTEMPORARY|ANCIENT|OLD|NEW|YOUNG|ELDER|SENIOR|JUNIOR|MAJOR|MINOR|PRIMARY|SECONDARY|TERTIARY|QUATERNARY|QUINARY|SENARY|SEPTENARY|OCTONARY|NONARY|DENARY)$/);
                if (titleMatch) {
                    patterns.titleSpeakers.push({ line: trimmedLine, index });
                }
                
                // Look for potential speakers based on context
                if (isPotentialSpeaker(trimmedLine, index, sceneContent)) {
                    patterns.potentialSpeakers.push({ line: trimmedLine, index });
                }
            });
            
            return patterns;
        }

        // Check if a line is a potential speaker based on context
        function isPotentialSpeaker(line, index, sceneContent) {
            // Skip if line is too short or too long
            if (line.length < 3 || line.length > 50) return false;
            
            // Skip if it's clearly not a speaker
            if (line.startsWith('[') || line.endsWith(']') || 
                line.includes('ACT') || line.includes('SCENE') ||
                line.includes('ENTER') || line.includes('EXIT') || line.includes('EXEUNT')) {
                return false;
            }
            
            // Simple check: if it's all caps and reasonable length, it might be a speaker
            if (line.match(/^[A-Z\s]+$/) && line.length > 2 && line.length < 50) {
                // Quick check for the next few lines to see if there's dialogue
                const nextLines = sceneContent.slice(index + 1, index + 3);
                for (let i = 0; i < nextLines.length; i++) {
                    const nextLine = nextLines[i].trim();
                    if (nextLine && nextLine.length > 10 && !nextLine.match(/^[A-Z\s]+$/)) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        // Check if a line represents a speaker using multiple detection methods
        function isSpeakerLine(line, patterns, index, sceneContent) {
            const trimmedLine = line.trim();
            
            // Check for bold text patterns
            if (trimmedLine.startsWith('**') && trimmedLine.endsWith('**')) {
                return true;
            }
            
            // Primary check: All caps speaker names (most common pattern)
            if (trimmedLine.match(/^[A-Z\s,]+$/) && trimmedLine.length > 2 && trimmedLine.length < 50) {
                // Avoid stage directions and scene markers
                const stageDirections = ['ACT', 'SCENE', 'ENTER', 'EXIT', 'EXEUNT', 'WITHIN', 'ABOVE', 'BELOW', 'CURTAIN'];
                const upperLine = trimmedLine.toUpperCase();
                
                if (stageDirections.some(word => upperLine.includes(word))) {
                    return false;
                }
                
                // Check if this line is followed by dialogue (not another speaker)
                const nextLines = sceneContent.slice(index + 1, index + 3);
                for (const nextLine of nextLines) {
                    const nextTrimmed = nextLine.trim();
                    if (nextTrimmed && nextTrimmed.length > 5) {
                        // If next line is also all caps, this might not be a speaker
                        if (nextTrimmed.match(/^[A-Z\s,]+$/)) {
                            continue;
                        }
                        // If next line looks like dialogue, this is likely a speaker
                        return true;
                    }
                }
            }
            
            // Check if this line matches any of our identified patterns
            const allPatterns = [
                ...patterns.boldText,
                ...patterns.allCaps,
                ...patterns.numberedSpeakers,
                ...patterns.titleSpeakers,
                ...patterns.potentialSpeakers
            ];
            
            // Check if this line is in our identified patterns
            for (const pattern of allPatterns) {
                if (pattern.line === trimmedLine && pattern.index === index) {
                    return true;
                }
            }
            
            return false;
        }



        // Process unattributed lines to handle bracketed text and inline speakers
        function processUnattributedLine(line) {
            // First, check if this line contains an inline speaker (all caps followed by dialogue)
            const speakerMatch = line.match(/^([A-Z\s,]+)\s+(.+)$/);
            if (speakerMatch) {
                const speakerName = speakerMatch[1].trim();
                const dialogue = speakerMatch[2].trim();
                
                // Check if the speaker name looks like a real speaker (not stage direction)
                const stageDirections = ['ACT', 'SCENE', 'ENTER', 'EXIT', 'EXEUNT', 'WITHIN', 'ABOVE', 'BELOW', 'CURTAIN'];
                const upperSpeaker = speakerName.toUpperCase();
                
                if (!stageDirections.some(word => upperSpeaker.includes(word))) {
                    // This is an inline speaker - format it properly
                    const formattedDialogue = formatBracketedText(dialogue);
                    return `<div class="character-name">${speakerName}</div><div class="dialogue-text">${formattedDialogue}</div>`;
                }
            }
            
            // If no inline speaker, just format bracketed text
            return formatBracketedText(line);
        }

        // Format text to make bracketed content italic
        function formatBracketedText(text) {
            console.log('formatBracketedText called with:', text);
            // Replace all text within brackets with italic version
            // This handles both complete bracketed lines and bracketed text within lines
            let result = text;
            
            // Handle complete bracketed lines
            if (text.trim().startsWith('[') && text.trim().endsWith(']')) {
                result = `<em>${text.trim()}</em>`;
                console.log('Complete bracketed line formatted:', result);
            } else {
                // Handle bracketed text within lines
                result = text.replace(/\[([^\]]+)\]/g, '<em>[$1]</em>');
                console.log('Partial bracketed text formatted:', result);
            }
            
            return result;
        }

        // Extract speaker name from a line
        function extractSpeakerName(line) {
            // Remove bold markers if present
            if (line.startsWith('**') && line.endsWith('**')) {
                return line.slice(2, -2);
            }
            
            // Return the line as-is for other patterns
            return line;
        }

        // Update active navigation
        function updateActiveNavigation(itemName) {
            const navLinks = document.querySelectorAll('.navigation-list a');
            navLinks.forEach(link => {
                link.classList.remove('active');
            });
            
            // If it's a scene, highlight both the scene and its parent act
            if (itemName && itemName.includes(' - ')) {
                const actName = itemName.split(' - ')[0];
                
                navLinks.forEach(link => {
                    // Highlight the parent act
                    if (link.textContent === actName) {
                        link.classList.add('active');
                    }
                    
                    // Highlight the specific scene using data attribute
                    if (link.getAttribute('data-scene') === itemName) {
                        link.classList.add('active');
                    }
                });
            } else if (itemName === 'dramatis') {
                // Highlight Dramatis Personae
                navLinks.forEach(link => {
                    if (link.textContent === 'Dramatis Personae') {
                        link.classList.add('active');
                    }
                });
            } else if (itemName) {
                // Highlight just the act
                navLinks.forEach(link => {
                    if (link.textContent === itemName) {
                        link.classList.add('active');
                    }
                });
            }
        }

        // Show Dramatis Personae
        function showDramatisPersonae() {
            if (!currentPlay || !plays[currentPlay]) return;
            
            const characters = plays[currentPlay].characters;
            const playText = document.getElementById('playText');
            
            // Update active navigation
            updateActiveNavigation('dramatis');
            
            playText.innerHTML = `
                <div class="scene-title">Dramatis Personae</div>
                <div class="scene-separator"></div>
                <div class="analysis-content">
                    ${characters.length > 0 ? 
                        characters.map(char => `<p><strong>${char}</strong></p>`).join('') :
                        '<p><em>No character list found in this play.</em></p>'
                    }
                </div>
            `;
        }

        // Show Act overview
        function showAct(actName) {
            if (!currentPlay || !plays[currentPlay] || !plays[currentPlay].acts[actName]) return;
            
            const scenes = plays[currentPlay].acts[actName];
            const playText = document.getElementById('playText');
            
            // Update active navigation
            updateActiveNavigation(actName);
            
            playText.innerHTML = `
                <div class="scene-title">${actName}</div>
                <div class="scene-separator"></div>
                <div class="analysis-content">
                    <p>This act contains ${scenes.length} scene${scenes.length !== 1 ? 's' : ''}:</p>
                    ${scenes.map(scene => `<p><a href="#" onclick="loadScene('${scene}')">${scene.split(' - ')[1]}</a></p>`).join('')}
                </div>
            `;
        }

        // Change play
        function changePlay() {
            const selector = document.getElementById('playSelector');
            const selectedPlay = selector.value;
            if (selectedPlay) {
                loadPlay(selectedPlay);
            }
        }

        // Text selection functionality
        document.addEventListener('selectionchange', () => {
            const s = window.getSelection();
            const t = document.getElementById('selectionToolbar');
            
            // Check if there's no selection, selection is collapsed, or no text is selected
            if (!s || s.isCollapsed || s.toString().trim() === '') {
                t.hidden = true;
                t.style.display = 'none';
                selectedText = '';
                return;
            }
            
            // Additional check: ensure selection is within the reading pane
            const readerElement = document.querySelector('.reader');
            if (!readerElement) {
                t.hidden = true;
                t.style.display = 'none';
                selectedText = '';
                return;
            }
            
            // Check if the selection is actually within the reading pane
            const selectionRange = s.getRangeAt(0);
            if (!readerElement.contains(selectionRange.commonAncestorContainer)) {
                t.hidden = true;
                t.style.display = 'none';
                selectedText = '';
                return;
            }
            
            // Get the bounding rectangle of the selection
            const box = s.rangeCount ? s.getRangeAt(0).getBoundingClientRect() : null;
            
            if (!box) {
                t.hidden = true;
                t.style.display = 'none';
                return;
            }
            
            // Position the toolbar above the selection, constrained to reading pane
            const reader = readerElement;
            if (reader) {
                const readerRect = reader.getBoundingClientRect();
                const readerScrollTop = reader.scrollTop;
                
                // Calculate position relative to the reading pane
                let left = box.left + box.width/2 - readerRect.left;
                let top = box.top - readerRect.top - 50; // 50px above the selection
                
                // Constrain to reading pane boundaries
                left = Math.max(10, Math.min(left, readerRect.width - 200)); // 10px margin, max 200px width
                top = Math.max(10, top); // At least 10px from top
                
                t.style.left = `${left}px`;
                t.style.top = `${top}px`;
                t.hidden = false;
                t.style.display = 'flex';
            } else {
                t.hidden = true;
                t.style.display = 'none';
            }
        });

        // Additional check for when selection is lost
        document.addEventListener('mouseup', () => {
            setTimeout(() => {
                const s = window.getSelection();
                const t = document.getElementById('selectionToolbar');
                
                if (!s || s.isCollapsed || s.toString().trim() === '') {
                    t.hidden = true;
                    selectedText = '';
                }
            }, 10);
        });

        // Hide toolbar when clicking anywhere on the page
        document.addEventListener('mousedown', (event) => {
            const toolbar = document.getElementById('selectionToolbar');
            const target = event.target;
            
            // Don't hide if clicking on the toolbar itself
            if (toolbar && toolbar.contains(target)) {
                return;
            }
            
            // Hide toolbar when clicking anywhere else
            if (toolbar && !toolbar.hidden) {
                toolbar.hidden = true;
                selectedText = '';
            }
        });

        // Alternative approach using click event
        document.addEventListener('click', (event) => {
            const toolbar = document.getElementById('selectionToolbar');
            const target = event.target;
            
            // Don't hide if clicking on the toolbar itself
            if (toolbar && toolbar.contains(target)) {
                return;
            }
            
            // Hide toolbar when clicking anywhere else
            if (toolbar && !toolbar.hidden) {
                console.log('Hiding toolbar via click event');
                toolbar.hidden = true;
                selectedText = '';
            }
        });

        // Force hide toolbar when selection is cleared
        document.addEventListener('mouseup', (event) => {
            setTimeout(() => {
                const s = window.getSelection();
                const toolbar = document.getElementById('selectionToolbar');
                
                // If toolbar is visible but no text is selected, hide it
                if (toolbar && !toolbar.hidden && (!s || s.isCollapsed || s.toString().trim() === '')) {
                    console.log('Hiding toolbar - no selection detected');
                    toolbar.hidden = true;
                    selectedText = '';
                }
            }, 50); // Longer timeout to ensure selection is cleared
        });

        // Hide toolbar with Escape key
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                const toolbar = document.getElementById('selectionToolbar');
                if (toolbar && !toolbar.hidden) {
                    console.log('Hiding toolbar via Escape key');
                    toolbar.hidden = true;
                    selectedText = '';
                }
            }
        });

        // Ensure toolbar is hidden on page load
        document.addEventListener('DOMContentLoaded', function() {
            const toolbar = document.getElementById('selectionToolbar');
            if (toolbar) {
                toolbar.hidden = true;
                toolbar.style.display = 'none';
            }
        });

        // Contextual toolbar button event listeners
        document.addEventListener('DOMContentLoaded', function() {
            const explainBtn = document.getElementById('explainBtn');
            const copyBtn = document.getElementById('copyBtn');
            
            if (explainBtn) {
                explainBtn.addEventListener('click', function() {
                    if (!selectedText) {
                        alert('Please select some text first.');
                        return;
                    }
                    analyzeHighlightedText(selectedText);
                    document.getElementById('selectionToolbar').hidden = true;
                });
            }
            
            if (copyBtn) {
                copyBtn.addEventListener('click', function() {
                    if (selectedText) {
                        navigator.clipboard.writeText(selectedText).then(() => {
                            // Show brief success feedback
                            const originalText = copyBtn.textContent;
                            copyBtn.textContent = 'Copied!';
                            setTimeout(() => {
                                copyBtn.textContent = originalText;
                            }, 1000);
                        }).catch(err => {
                            console.error('Failed to copy text: ', err);
                            alert('Failed to copy text to clipboard');
                        });
                        document.getElementById('selectionToolbar').hidden = true;
                    }
                });
            }
        });

        // Simple click outside to hide toolbar
        document.addEventListener('click', (event) => {
            const toolbar = document.getElementById('selectionToolbar');
            if (toolbar && !toolbar.hidden && !toolbar.contains(event.target)) {
                console.log('Hiding toolbar - clicked outside');
                toolbar.hidden = true;
                selectedText = '';
            }
        });



        // Function to clear all existing highlights
        function clearAllHighlights() {
            const highlights = document.querySelectorAll('.highlight');
            highlights.forEach(highlight => {
                const parent = highlight.parentNode;
                parent.replaceChild(document.createTextNode(highlight.textContent), highlight);
                parent.normalize(); // Merge adjacent text nodes
            });
        }

        document.addEventListener('mouseup', function() {
            const selection = window.getSelection();
            selectedText = selection.toString().trim();
            
            if (selectedText) {
                // Clear any existing highlights first
                clearAllHighlights();
                
                // Highlight the selected text
                const range = selection.getRangeAt(0);
                const span = document.createElement('span');
                span.className = 'highlight';
                range.surroundContents(span);
            }
        });

        // Clear highlights when clicking in the reading pane without selecting text
        document.addEventListener('click', function(event) {
            // Only clear highlights if clicking in the reading pane and no text is selected
            if (event.target.closest('.reader') && !window.getSelection().toString().trim()) {
                clearAllHighlights();
                selectedText = '';
            }
        });

        // Contextual toolbar event listeners




        function explainHighlighted() {
            if (!selectedText) {
                alert('Please highlight some text first, then click "Explain Highlighted Text".');
                return;
            }
            
            // Call the serverless function to analyze the highlighted text
            analyzeHighlightedText(selectedText);
        }

        async function analyzeHighlightedText(text) {
            // Show "Researching!" message immediately
            const analysisPanel = document.getElementById('analysisPanel');
            analysisPanel.innerHTML = `
                <div class="analysis-header">
                    <div class="analysis-title researching">Researching!</div>
                </div>
                <div class="analysis-content">
                    <p class="analyzing-message">
                        <img src="images/shakespeare-thinking.png" alt="Shakespeare thinking" class="shakespeare-icon">
                        Analyzing your selected text...
                    </p>
                </div>
            `;
            
            try {
                console.log('Analyzing text:', text.substring(0, 100) + '...');
                
                // Try the redirect path first
                let response = await fetch('/api/shakespeare', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: text,
                        level: currentAnalysisMode,
                        model: 'gpt-4o-mini'
                    })
                });
                
                // If that fails, try the direct function path
                if (!response.ok) {
                    console.log('Redirect failed, trying direct function path...');
                    response = await fetch('/.netlify/functions/shakespeare', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            text: text,
                            level: currentAnalysisMode,
                            model: 'gpt-4o-mini'
                        })
                    });
                }
                
                console.log('Response status:', response.status);
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('Server error:', errorData);
                    
                    if (response.status === 500 && errorData.error && errorData.error.includes('API key')) {
                        alert('OpenAI API key not configured. Please check your Netlify environment variables.');
                    } else {
                        throw new Error(`HTTP ${response.status}: ${errorData.error || 'Unknown error'}`);
                    }
                    return;
                }
                
                const data = await response.json();
                console.log('Response data:', data);
                
                if (data.choices && data.choices[0] && data.choices[0].message) {
                    updateAnalysis(data.choices[0].message.content, text);
                } else if (data.error) {
                    throw new Error(data.error);
                } else {
                    throw new Error('Invalid response format from server');
                }
                
            } catch (error) {
                console.error('Error analyzing text:', error);
                
                // More specific error messages
                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    alert('Network error. Please check your internet connection and try again.');
                } else if (error.message.includes('API key')) {
                    alert('OpenAI API key not configured. Please check your Netlify environment variables.');
                } else {
                    alert(`Error analyzing text: ${error.message}. Please try again.`);
                }
            }
        }

        function updateAnalysis(content, text) {
            const analysisPanel = document.getElementById('analysisPanel');
            const wordCount = text.split(' ').length;
            const playName = currentPlay && plays[currentPlay] ? plays[currentPlay].name : 'Unknown Play';
            const playInfo = `${playName} · ${currentScene}`;
            
            // Format the content with proper sections
            const formattedContent = formatAnalysisContent(content);
            
            // Get the correct title based on current mode
            let analysisTitle = 'Basic Analysis';
            switch(currentAnalysisMode) {
                case 'basic':
                    analysisTitle = 'Basic Analysis';
                    break;
                case 'intermediate':
                    analysisTitle = 'Intermediate Analysis';
                    break;
                case 'expert':
                    analysisTitle = 'Expert Analysis';
                    break;
                case 'fullfathomfive':
                    analysisTitle = 'Full Fathom Five Analysis';
                    break;
            }
            
            analysisPanel.innerHTML = `
                <!-- Analysis Mode Selector -->
                <div class="segment">
                    <button onclick="setAnalysisMode('basic')" aria-pressed="${currentAnalysisMode === 'basic' ? 'true' : 'false'}">Basic</button>
                    <button onclick="setAnalysisMode('intermediate')" aria-pressed="${currentAnalysisMode === 'intermediate' ? 'true' : 'false'}">Intermediate</button>
                    <button onclick="setAnalysisMode('expert')" aria-pressed="${currentAnalysisMode === 'expert' ? 'true' : 'false'}">Expert</button>
                    <button onclick="setAnalysisMode('fullfathomfive')" aria-pressed="${currentAnalysisMode === 'fullfathomfive' ? 'true' : 'false'}">Full Fathom Five</button>
                </div>

                <!-- AI Analysis Content -->
                <div class="analysis">
                    <button class="copy-chip" onclick="copyAnalysis()">Copy</button>
                    <div class="meta">${playInfo} — ${wordCount} words selected</div>
                    <div class="analysis-content">
                        ${formattedContent}
                    </div>
                </div>

                            <!-- Media Section -->
            <h3>Media</h3>
            <div class="media-actions">
                <button class="link-btn youtube" onclick="searchYouTube('scene')">Search YouTube for this scene</button>
            </div>

            <!-- Research Section -->
            <h3>Research</h3>
            <div class="research-actions">
                <button class="link-btn jstor" onclick="searchJSTOR('exact')">Search JSTOR for exact quotation</button>
                <button class="link-btn jstor" onclick="searchJSTOR('passage')">Search JSTOR for this passage/scene</button>
                <button class="link-btn scholar" onclick="searchGoogleScholar()">Google Scholar</button>
                <button class="link-btn ise" onclick="openInternetShakespeare()">Internet Shakespeare Editions</button>
            </div>

            <!-- Follow-up Section -->
            <h3>Ask a follow-up question</h3>
            <div class="follow-up-input">
                <input type="text" placeholder="Ask a follow-up question..." id="followUpQuestion">
                <button class="ask-btn" onclick="askFollowUp()">Ask</button>
            </div>
            `;
        }

        function formatAnalysisContent(content) {
            // First, handle the specific Basic analysis format with ** headers
            if (currentAnalysisMode === 'basic') {
                // Parse the content into structured sections
                const sections = content.split(/\n\n+/);
                let formattedContent = '';
                
                sections.forEach((section, index) => {
                    const trimmedSection = section.trim();
                    if (!trimmedSection) return;
                    
                    // Check for key-value pairs (Label — content)
                    if (trimmedSection.includes('—')) {
                        const parts = trimmedSection.split('—', 2);
                        if (parts.length === 2) {
                            const label = parts[0].replace(/\*\*(.*?)\*\*/g, '$1').trim();
                            const content = parts[1].trim();
                            formattedContent += `<p class="kv"><span class="k">${label}</span><span class="sep">—</span>${content}</p>`;
                        } else {
                            formattedContent += `<p>${trimmedSection}</p>`;
                        }
                    } else if (trimmedSection.toLowerCase().includes('key words')) {
                        // Handle Key Words section specially
                        formattedContent += `<h3>Key Words</h3>`;
                        // Extract word definitions (assuming format: word — definition)
                        const lines = trimmedSection.split('\n').slice(1); // Skip the "Key Words" line
                        let dlContent = '';
                        lines.forEach(line => {
                            if (line.includes('—')) {
                                const [word, def] = line.split('—', 2);
                                if (word && def) {
                                    dlContent += `<dt>${word.trim()}</dt><dd> — ${def.trim()}</dd>`;
                                }
                            }
                        });
                        if (dlContent) {
                            formattedContent += `<dl>${dlContent}</dl>`;
                        }
                    } else if (trimmedSection.toLowerCase().includes('synopsis') || 
                               trimmedSection.toLowerCase().includes('prosody') ||
                               trimmedSection.toLowerCase().includes('context') ||
                               trimmedSection.toLowerCase().includes('function')) {
                        // Handle other sections with h3 headers
                        const lines = trimmedSection.split('\n');
                        const title = lines[0].replace(/\*\*(.*?)\*\*/g, '$1').trim();
                        const content = lines.slice(1).join('\n').trim();
                        formattedContent += `<h3>${title}</h3><p>${content}</p>`;
                    } else {
                        // Default paragraph
                        formattedContent += `<p>${trimmedSection}</p>`;
                    }
                });
                
                return formattedContent;
            }
            
            // For other analysis modes, use the original logic
            const sections = content.split(/\n\n+/);
            let formattedContent = '';
            
            sections.forEach((section, index) => {
                const trimmedSection = section.trim();
                if (!trimmedSection) return;
                
                // Check if this looks like a section that should have a header
                if (index === 0) {
                    // First section is usually the main analysis
                    formattedContent += `<p>${trimmedSection}</p>`;
                } else if (trimmedSection.toLowerCase().includes('etymology') || 
                           trimmedSection.toLowerCase().includes('word') ||
                           trimmedSection.toLowerCase().includes('meaning')) {
                    formattedContent += `<h4>Etymology & Word Origins</h4><p>${trimmedSection}</p>`;
                } else if (trimmedSection.toLowerCase().includes('critic') || 
                           trimmedSection.toLowerCase().includes('scholar') ||
                           trimmedSection.toLowerCase().includes('interpretation')) {
                    formattedContent += `<h4>What Critics Say</h4><p>${trimmedSection}</p>`;
                } else if (trimmedSection.toLowerCase().includes('performance') || 
                           trimmedSection.toLowerCase().includes('stage') ||
                           trimmedSection.toLowerCase().includes('production')) {
                    formattedContent += `<h4>Performance Insights</h4><p>${trimmedSection}</p>`;
                } else if (trimmedSection.toLowerCase().includes('theme') || 
                           trimmedSection.toLowerCase().includes('symbol') ||
                           trimmedSection.toLowerCase().includes('motif')) {
                    formattedContent += `<h4>Themes & Symbolism</h4><p>${trimmedSection}</p>`;
                } else if (trimmedSection.toLowerCase().includes('context') || 
                           trimmedSection.toLowerCase().includes('historical') ||
                           trimmedSection.toLowerCase().includes('background')) {
                    formattedContent += `<h4>Historical Context</h4><p>${trimmedSection}</p>`;
                } else {
                    // Default section
                    formattedContent += `<h4>Additional Analysis</h4><p>${trimmedSection}</p>`;
                }
            });
            
            return formattedContent;
        }

        // Analysis mode state
        let currentAnalysisMode = 'basic';

        function setAnalysisMode(mode) {
            currentAnalysisMode = mode;
            
            // Update button states
            const buttons = document.querySelectorAll('.segment button');
            buttons.forEach(btn => {
                btn.setAttribute('aria-pressed', 'false');
            });
            event.target.setAttribute('aria-pressed', 'true');
            
            // Update the analysis title based on mode
            const analysisTitle = document.querySelector('.analysis-title');
            if (analysisTitle) {
                switch(mode) {
                    case 'basic':
                        analysisTitle.textContent = 'Basic Analysis';
                        break;
                    case 'intermediate':
                        analysisTitle.textContent = 'Intermediate Analysis';
                        break;
                    case 'expert':
                        analysisTitle.textContent = 'Expert Analysis';
                        break;
                    case 'fullfathomfive':
                        analysisTitle.textContent = 'Full Fathom Five Analysis';
                        break;
                }
            }
            
            // If there's currently selected text, re-analyze with new mode
            if (selectedText) {
                analyzeHighlightedText(selectedText);
            }
        }

        function copyAnalysis() {
            const analysisContent = document.querySelector('.analysis-content');
            if (analysisContent) {
                const textToCopy = analysisContent.innerText;
                navigator.clipboard.writeText(textToCopy).then(() => {
                    // Show a brief success message
                    const copyBtn = document.querySelector('.copy-btn');
                    if (copyBtn) {
                        const originalText = copyBtn.textContent;
                        copyBtn.textContent = 'Copied!';
                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                        }, 1000);
                    }
                }).catch(err => {
                    console.error('Failed to copy text: ', err);
                    alert('Failed to copy analysis to clipboard');
                });
            }
        }

        function askFollowUp() {
            const question = document.getElementById('followUpQuestion').value.trim();
            if (!question) {
                alert('Please enter a question.');
                return;
            }
            
            // Here you would implement follow-up question functionality
            alert('Follow-up question feature coming soon!');
        }

        // Media and Research Functions
        function searchYouTube(type) {
            const playName = currentPlay && plays[currentPlay] ? plays[currentPlay].name : 'Shakespeare';
            const sceneName = currentScene || 'scene';
            const searchQuery = `${playName} ${sceneName} performance`;
            
            const url = `https://www.youtube.com/results?search_query=${encodeURIComponent(searchQuery)}`;
            window.open(url, '_blank');
        }

        function searchJSTOR(type) {
            if (!selectedText) {
                alert('Please select some text first to search JSTOR.');
                return;
            }
            
            let searchQuery = '';
            if (type === 'exact') {
                searchQuery = `"${selectedText}"`;
            } else {
                const playName = currentPlay && plays[currentPlay] ? plays[currentPlay].name : 'Shakespeare';
                searchQuery = `${playName} ${currentScene || 'scene'}`;
            }
            
            const url = `https://www.jstor.org/action/doBasicSearch?Query=${encodeURIComponent(searchQuery)}`;
            window.open(url, '_blank');
        }

        function searchGoogleScholar() {
            const playName = currentPlay && plays[currentPlay] ? plays[currentPlay].name : 'Shakespeare';
            const sceneName = currentScene || 'scene';
            
            // Extract Act information from the scene name
            let actInfo = '';
            if (currentScene && currentScene.includes(' - ')) {
                const actPart = currentScene.split(' - ')[0];
                if (actPart && actPart.includes('ACT')) {
                    actInfo = actPart;
                }
            }
            
            // Build search query with Act information
            let searchQuery = '';
            if (actInfo) {
                searchQuery = `${playName} ${actInfo} Shakespeare`;
            } else {
                searchQuery = `${playName} ${sceneName} Shakespeare`;
            }
            
            const url = `https://scholar.google.com/scholar?q=${encodeURIComponent(searchQuery)}`;
            window.open(url, '_blank');
        }

        function openInternetShakespeare() {
            const playName = currentPlay && plays[currentPlay] ? plays[currentPlay].name.toLowerCase().replace(/\s+/g, '-') : 'shakespeare';
            const url = `https://internetshakespeare.uvic.ca/Library/plays/${playName}/`;
            window.open(url, '_blank');
        }




    </script>

    <!-- Footer About Section -->
    <footer class="footer-about">
        <div class="footer-title">About This Project</div>
        <div>
            Shakespeare Digital Variorum combines centuries of scholarly commentary with AI analysis.
            All Shakespeare texts are public domain and based on the Folger Shakespeare Library editions.
        </div>
        <div>
            Created by Jack David Carson, Massachusetts Institute of Technology · 2025 ·
            <a href="#" onclick="openRights(); return false;">Full Rights & Usage Information</a>
        </div>
    </footer>
</body>
</html>

